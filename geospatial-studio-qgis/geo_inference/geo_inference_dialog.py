# Â© Copyright IBM Corporation 2025
# SPDX-License-Identifier: Apache-2.0


# -*- coding: utf-8 -*-
"""
/***************************************************************************
 GeoInferenceDialog
                                 A QGIS plugin
 This plugin helps run inferences
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2025-06-11
        git sha              : $Format:%H$
        copyright            : (C) 2025 by IBM
        email                : Fiona.Bundi@ibm.com
 ***************************************************************************/

/***************************************************************************
 * *
 * This program is free software; you can redistribute it and/or modify  *
 * it under the terms of the GNU General Public License as published by  *
 * the Free Software Foundation; either version 2 of the License, or     *
 * (at your option) any later version.                                   *
 * *
 ***************************************************************************/
"""

import json

import requests
from PyQt5.QtWidgets import QApplication
from qgis.core import Qgis, QgsMessageLog, QgsProject
from qgis.PyQt import QtWidgets
from qgis.PyQt.QtCore import QDate, Qt
from qgis.PyQt.QtWidgets import (
    QDateEdit,
    QGroupBox,
    QHBoxLayout,
    QLabel,
    QLineEdit,
    QListWidget,
    QMessageBox,
    QProgressBar,
    QPushButton,
    QTextEdit,
    QVBoxLayout,
)
from qgis.utils import iface

from .config import BASE_URL, INFERENCE_URL
from .geo_inference_api import GeoInferenceApi
from .geo_inference_spatial_Selector import SpatialSelector
from .geo_inference_wms_manager import WMSManager


class GeoInferenceDialog(QtWidgets.QDialog):
    """
    Main dialog class for the GeoInference plugin.
    Coordinates between UI and API logic.
    """

    def __init__(self, parent=None):
        super(GeoInferenceDialog, self).__init__(parent)

        self.base_url = BASE_URL
        self.inf_url = INFERENCE_URL

        # Instantiate the API handler
        self.api_handler = GeoInferenceApi(self.base_url, self.inf_url)

        # Instantiate the wmsManager
        self.wms_manager = WMSManager()

        # Instantiate the spatial selector
        self.spatial_selector = SpatialSelector()

        # store the inference
        self.current_inference_data = None

        self.setupUi()
        self.connect_components()

    def setupUi(self):
        """
        Sets up the main dialog's user interface.
        """
        self.setWindowTitle("GEO Studio - Inference Management")
        self.setMinimumSize(800, 900)
        main_layout = QVBoxLayout()
        self.setLayout(main_layout)

        # API Key Input
        api_key_group = QGroupBox()
        api_key_layout = QHBoxLayout()  # Changed from QVBoxLayout to QHBoxLayout
        api_key_group.setLayout(api_key_layout)

        api_key_layout.addWidget(QLabel("Enter your API Key:"))
        self.api_key_input = QLineEdit()
        self.api_key_input.setPlaceholderText("Paste your API key here...")
        self.api_key_input.setEchoMode(QLineEdit.Password)
        self.api_key_input.setMaximumWidth(300)
        api_key_layout.addWidget(self.api_key_input)

        api_key_layout.addStretch()

        main_layout.addWidget(api_key_group)

        load_section = QGroupBox("Load Inferences")
        load_section.setStyleSheet(
            """
            QGroupBox#load_section {
                border: 1px solid #ccc;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox#load_section::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px;
            }
        """
        )
        load_section.setObjectName("load_section")
        load_layout = QVBoxLayout()
        load_section.setLayout(load_layout)
        # Control Buttons
        controls_layout = QHBoxLayout()
        self.list_inference_btn = QPushButton("List Inferences")
        controls_layout.addWidget(self.list_inference_btn)

        controls_layout.addStretch()
        load_layout.addLayout(controls_layout)
        # Progress Bar
        self.progress_bar = QProgressBar()
        self.progress_bar.setVisible(False)
        self.progress_bar.setTextVisible(True)
        load_layout.addWidget(self.progress_bar)

        # Inferences list Display
        results_group = QGroupBox("Inference Results")
        results_layout = QVBoxLayout()
        results_group.setLayout(results_layout)

        results_layout.addWidget(QLabel("Inferences:"))
        self.results_list = QListWidget()
        results_layout.addWidget(self.results_list)

        results_layout.addWidget(QLabel("Details:"))
        self.details_text = QTextEdit()
        # self.details_text.setMaximumHeight(200)
        self.details_text.setPlaceholderText("Select an inference to view details...")
        results_layout.addWidget(self.details_text)
        load_layout.addWidget(results_group)

        # Download from presigned url
        download_layout = QHBoxLayout()
        self.load_layers_btn = QPushButton("Download Geo tiff Layers")
        self.load_layers_btn.setStyleSheet("color:white;")
        self.load_layers_btn.setToolTip("Download geo tiff files and add them as layers to QGIS project")
        self.load_layers_btn.setEnabled(False)  # Disabled by default
        self.load_layers_btn.clicked.connect(self.on_load_layers_clicked)

        # button to load from geoserver
        self.download_layers_btn = QPushButton("Load Img from geoserver")
        self.download_layers_btn.setToolTip("Gets png images and add selected WMS layers to QGIS project")
        self.download_layers_btn.setStyleSheet("color:white;")
        self.load_layers_btn.setEnabled(True)  # Enable for now -> disable later
        self.download_layers_btn.clicked.connect(self.add_qgis_image)

        download_layout.addWidget(self.download_layers_btn)
        download_layout.addWidget(self.load_layers_btn)
        download_layout.addStretch()

        load_layout.addLayout(download_layout)

        main_layout.addWidget(load_section)
        main_layout.addSpacing(20)

        # submit inferences section
        submit_section = QGroupBox("Submit New Inference")
        submit_section.setStyleSheet(
            """
            QGroupBox#submit_section {
                border: 1px solid #ccc;
                border-radius: 5px;
                margin-top: 10px;
                padding-top: 10px;
            }
            QGroupBox#submit_section::title {
                subcontrol-origin: margin;
                left: 10px;
                padding: 0 5px;
            }
        """
        )
        submit_section.setObjectName("submit_section")
        submit_layout = QVBoxLayout()
        submit_section.setLayout(submit_layout)

        # spatial selection buttons
        spatial_group = QGroupBox("Spatial Selection")
        spatial_layout = QHBoxLayout()
        spatial_group.setLayout(spatial_layout)

        # create draw polygon button
        self.draw_btn = QPushButton("Select an Area")

        # Model Selection Group
        model_group = QGroupBox("Model Selection")
        model_layout = QVBoxLayout()
        model_group.setLayout(model_layout)

        #  load models button
        self.load_models_btn = QPushButton("Load Models")
        self.load_models_btn.setStyleSheet("color:white;")
        self.load_models_btn.setEnabled(False)  # Disabled by default until API key is entered
        self.load_models_btn.clicked.connect(self.load_models)
        self.load_models_btn.setMaximumWidth(100)
        model_layout.addWidget(self.load_models_btn)

        model_layout.addWidget(QLabel("Select Model:"))
        self.models_list = QListWidget()
        self.models_list.setMaximumHeight(100)
        model_layout.addWidget(self.models_list)

        submit_layout.addWidget(model_group)
        # style the model selection
        self.models_list.setSelectionMode(QtWidgets.QAbstractItemView.SingleSelection)
        self.models_list.setStyleSheet("QListWidget::item:selected { background-color: #0078d4; }")

        # Parameters group
        params_group = QGroupBox("Inference Parameters")
        params_layout = QVBoxLayout()
        params_group.setLayout(params_layout)

        # Temporal Domain (Date Range )
        temporal_layout = QVBoxLayout()

        # Header
        date_header = QHBoxLayout()
        date_header.addWidget(QLabel("Date Range:"))
        date_header.addStretch()
        temporal_layout.addLayout(date_header)

        # Date pickers row
        date_picker_layout = QHBoxLayout()

        # Start Date
        start_date_container = QVBoxLayout()
        start_date_container.addWidget(QLabel("From:"))
        self.start_date_picker = QDateEdit()
        self.start_date_picker.setDate(QDate(2020, 1, 1))  # Default
        self.start_date_picker.setCalendarPopup(True)
        self.start_date_picker.setDisplayFormat("yyyy-MM-dd")
        self.start_date_picker.setMaximumWidth(130)
        self.start_date_picker.setStyleSheet(
            """
            QDateEdit {
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 6px 25px 6px 6px;
                font-size: 12px;
                min-height: 18px
            }
            QDateEdit::drop-down {
                subcontrol-origin: padding;
                subcontrol-position: top right;
                width: 20px;
                border-left: 1px solid #ccc;

            }
            QDateEdit::down-arrow {
                image: url(./calendar.png);
                width: 16px;
                height: 16px;

            }
        """
        )
        start_date_container.addWidget(self.start_date_picker)
        date_picker_layout.addLayout(start_date_container)

        # End Date
        end_date_container = QVBoxLayout()
        end_date_container.addWidget(QLabel("To:"))
        self.end_date_picker = QDateEdit()
        self.end_date_picker.setDate(QDate.currentDate())
        self.end_date_picker.setMinimumHeight(18)
        self.end_date_picker.setCalendarPopup(True)
        self.end_date_picker.setDisplayFormat("yyyy-MM-dd")
        self.end_date_picker.setMaximumWidth(130)
        self.end_date_picker.setStyleSheet(self.start_date_picker.styleSheet())
        end_date_container.addWidget(self.end_date_picker)
        date_picker_layout.addLayout(end_date_container)

        date_picker_layout.addStretch()
        params_layout.addLayout(temporal_layout)

        temporal_layout.addLayout(date_picker_layout)
        params_layout.addLayout(temporal_layout)

        # Description Input
        desc_layout = QHBoxLayout()
        desc_layout.addWidget(QLabel("ðŸ“ Description:"))
        self.description_input = QLineEdit()
        self.description_input.setPlaceholderText("Enter description for this inference...")
        self.description_input.setStyleSheet(
            """
            QLineEdit {
                border: 1px solid #ccc;
                border-radius: 4px;
                padding: 6px;
                font-size: 12px;
            }
        """
        )
        desc_layout.addWidget(self.description_input)
        params_layout.addLayout(desc_layout)

        # Add the params group to main layout
        submit_layout.addWidget(params_group)

        # submit inference btn
        self.submit_inference_btn = QPushButton("Submit Inference Request")

        # add the buttons to spatial layout
        spatial_layout.addWidget(self.draw_btn)
        spatial_layout.addWidget(self.submit_inference_btn)
        spatial_layout.addStretch()

        # add spatial group to main layout
        submit_layout.addWidget(spatial_group)

        main_layout.addWidget(submit_section)

        # Close Button
        close_layout = QHBoxLayout()
        self.close_btn = QPushButton("Close")
        close_layout.addStretch()
        close_layout.addWidget(self.close_btn)
        main_layout.addLayout(close_layout)

    def connect_components(self):
        """
        Connects signals from UI elements.
        """
        self.list_inference_btn.clicked.connect(self.list_inferences)
        self.results_list.itemClicked.connect(self.on_item_selected)
        self.close_btn.clicked.connect(self.close)

        # connect the bounding box & submit inference btns
        self.draw_btn.clicked.connect(self.spatial_selector.draw_polygon)
        self.submit_inference_btn.clicked.connect(self.submit_inference_with_bbox)

        self.api_key_input.textChanged.connect(self.on_api_key_changed)

    def list_inferences(self):
        """Triggers the API call to list inferences and updates UI based on result."""
        api_key = self.api_key_input.text().strip()

        if not api_key:
            QMessageBox.warning(
                self,
                "API Key Missing",
                "Please enter an API key before listing inferences.",
            )
            return

        # Set the API key in the handler
        self.api_handler.set_auth_credentials(api_key, "X-Api-Key")

        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0, 0)
        self.results_list.clear()
        self.details_text.clear()
        success, result = self.api_handler.list_inferences()

        if success:
            inferences = result
            if inferences:
                for i, inference in enumerate(inferences):
                    if isinstance(inference, dict):
                        inference_id = inference.get("id", f"Unknown_{i}")
                        location = inference.get("location", "Unknown")
                        status = inference.get("status", "Unknown")
                        display_text = f"ID: {inference_id} | " f"Location: {location} | Status: {status}"
                        item = QtWidgets.QListWidgetItem(display_text)
                        item.setData(Qt.UserRole, inference)
                        self.results_list.addItem(item)
                    else:
                        item = QtWidgets.QListWidgetItem(str(inference))
                        item.setData(Qt.UserRole, inference)
                        self.results_list.addItem(item)

                QMessageBox.information(
                    self,
                    "Success",
                    f"Successfully loaded {len(inferences)} inference(s).",
                )
            else:
                QMessageBox.information(self, "Info", "No inferences found.")
        else:
            QMessageBox.critical(self, "Error Listing Inferences", result)
        self.progress_bar.setVisible(False)

    def on_item_selected(self, item):
        """
        Handle selection of an inference item in the list.
        Shows detailed information about the selected inference.
        """
        inference_data = item.data(Qt.UserRole)
        QgsMessageLog.logMessage(f"Inference data: {inference_data}", "GeoFM", Qgis.Info)

        self.current_inference_data = inference_data
        details = (
            json.dumps(inference_data, indent=2, ensure_ascii=False)
            if isinstance(inference_data, dict)
            else str(inference_data)
        )
        self.details_text.setPlainText(details)
        self.load_layers_btn.setEnabled(True)

    def update_load_progress(self, current_index, total_layers, layer_name):
        """Update progress bar during layer loading."""
        self.progress_bar.setValue(current_index)
        self.progress_bar.setFormat(f"Loading layer {current_index + 1}/{total_layers}: {layer_name}")

    def handle_loading_finished(self, success, layer_count, error_message):
        """Handle completion of layer loading."""
        # Clean up UI
        self.progress_bar.setVisible(False)
        self.progress_bar.setFormat("")

        # Re-enable button
        self.load_layers_btn.setEnabled(True)

        # Show appropriate message
        if success:
            QMessageBox.information(self, "Success", f"Successfully loaded {layer_count} layers")
        else:
            QMessageBox.critical(self, "Error", f"Failed to load layers: {error_message}")

    def on_load_layers_clicked(self):
        """Handle the load layers button click - simple blocking version."""
        if not self.current_inference_data:
            QMessageBox.warning(self, "Warning", "No inference selected")
            return

        workspace = "geofm"
        layers = self.current_inference_data.get("geo_layers", [])

        if not layers:
            inference_id = self.current_inference_data.get("id")
            if inference_id:
                self.progress_bar.setVisible(True)
                self.progress_bar.setFormat("Getting task outputs...")
                self.load_layers_btn.setEnabled(False)

                try:
                    self.progress_bar.setFormat("Loading raster layers...")
                    success, task_outputs = self.api_handler.get_task_outputs(inference_id)
                    if success and task_outputs:
                        self.progress_bar.setFormat("Loading raster layers...")
                        self.progress_bar.setRange(0, len(task_outputs))
                        self.progress_bar.setValue(0)

                        # Load with progress tracking
                        loaded_count, failed_count = self.wms_manager.load_raster_layers_from_outputs(
                            task_outputs,
                            self.current_inference_data,
                            progress_callback=self.update_progress,
                        )

                        if loaded_count > 0:
                            QMessageBox.information(
                                self,
                                "Success",
                                f"Successfully loaded {loaded_count} raster layers",
                            )
                        else:
                            QMessageBox.warning(
                                self,
                                "Warning",
                                f"No layers loaded.{failed_count} failed.",
                            )
                    else:
                        QMessageBox.warning(self, "Warning", "No task outputs available")
                except Exception as e:
                    QMessageBox.critical(self, "Error", f"Failed to load task outputs: {str(e)}")
                finally:
                    self.load_layers_btn.setEnabled(True)
                    self.progress_bar.setVisible(False)
                return

        if not layers:
            QMessageBox.warning(self, "Warning", "No layers available")
            return

        # Load WMS layers if geo_layers was found.
        self.progress_bar.setVisible(True)
        self.progress_bar.setRange(0, len(layers))
        self.progress_bar.setValue(0)
        self.load_layers_btn.setEnabled(False)

        try:
            loaded_count = self.wms_manager.load_wms_layers(layers, workspace)

            self.progress_bar.setValue(len(layers))
            self.progress_bar.setFormat(f"Completed: {loaded_count} layers loaded")

            QMessageBox.information(self, "Success", f"Successfully loaded {loaded_count} layers")

        except Exception as e:
            QMessageBox.critical(self, "Error", f"Failed to load layers: {str(e)}")
        finally:
            self.load_layers_btn.setEnabled(True)
            self.progress_bar.setVisible(False)

    def update_progress(self, current, total, task_id):
        percentage = int((current / total) * 100)
        self.progress_bar.setValue(current)
        self.progress_bar.setFormat(f"Loading task {current + 1}/{total}... {percentage}%")
        QApplication.processEvents()

    def add_qgis_image(self):
        """Add inference output as raster layer to QGIS from a presigned url"""

        try:
            uris = []
            predicted_layers = self.current_inference_data["geoserver_layers"]["predicted_layers"]
            location = self.current_inference_data["location"]
            description = self.current_inference_data["description"]
            for layer in predicted_layers:
                uri = layer.get("uri")
                if uri:
                    uris.append(uri)

            # Create layer name

            workspace = "geofm"
            root = QgsProject.instance().layerTreeRoot()
            group = root.findGroup("WMS layers")
            if not group:
                group = root.insertGroup(0, f"WMS Layers{location}, {description}")

            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, len(uris) + 1)
            self.progress_bar.setValue(0)
            self.load_layers_btn.setEnabled(False)
            success_count = 0
            error_messages = []
            # Use WMS manager to add raster layer
            for i, uri in enumerate(uris):
                self.progress_bar.setValue(i + 1)

                success, message = self.wms_manager.add_wms_layer_to_qgis(workspace, uri, group, iface)

                if success:
                    success_count += 1
                else:
                    error_messages.append(message)

            self.progress_bar.setVisible(False)
        except Exception as e:
            error_msg = f"Failed to add image layer: {str(e)}"
            QgsMessageLog.logMessage(error_msg, "GEOFM", Qgis.Critical)
            QMessageBox.critical(self, "Error", error_msg)

    def submit_inference_with_bbox(self):
        """Submit inference request using the captured bounding box"""
        try:
            # Get bounding box from spatial selector
            bbox = self.spatial_selector.get_drawn_bbox()

            if not bbox:
                QMessageBox.warning(
                    self,
                    "No Bounding Box",
                    "Please draw polygons first and get the bounding box.",
                )
                return

            # Validate API key
            api_key = self.api_key_input.text().strip()
            if not api_key:
                QMessageBox.warning(
                    self,
                    "API Key Missing",
                    "Please enter your API key before submitting inference.",
                )
                return

            # Set API key in handler
            self.api_handler.set_auth_credentials(api_key, "X-Api-Key")

            # Check if model is selected
            current_item = self.models_list.currentItem()
            if current_item:
                selected_model_id = current_item.data(Qt.UserRole)
            else:
                selected_model_id = None

            if not selected_model_id:
                QMessageBox.warning(
                    self,
                    "No Model Selected",
                    "Please select a model from the list before submitting inference.",
                )
                return

                #  Get dates from date pickers
            start_date = self.start_date_picker.date().toString("yyyy-MM-dd")
            end_date = self.end_date_picker.date().toString("yyyy-MM-dd")
            description = self.description_input.text().strip()

            #  Validate date range
            if self.start_date_picker.date() > self.end_date_picker.date():
                QMessageBox.warning(self, "Invalid Date Range", "Start date must be before end date.")
                return

            #  Auto-detect location from bounding box
            location = self.get_location_from_bbox(bbox)

            # Show progress
            self.progress_bar.setVisible(True)
            self.progress_bar.setRange(0, 0)  # Indeterminate progress

            # Submit inference request
            QMessageBox.information(
                self,
                "Submitting Request",
                f"Submitting inference request for area:\n"
                f"West: {bbox[0]:.6f}\n"
                f"South: {bbox[1]:.6f}\n"
                f"East: {bbox[2]:.6f}\n"
                f"North: {bbox[3]:.6f}",
            )

            success, result = self.api_handler.submit_inference_request(
                bbox=bbox,
                model_id=selected_model_id,
                start_date=start_date,
                end_date=end_date,
                description=description,
                location=location,
            )

            self.progress_bar.setVisible(False)

            if success:
                # Success show result and get inference list
                inference_id = result.get("id", "Unknown")
                QMessageBox.information(
                    self,
                    "Inference Submitted",
                    f"Inference request submitted successfully!\n"
                    f"Inference ID: {inference_id}\n\n"
                    f"The inference is now processing. "
                    f"Click 'list inferences' to check status.",
                )

            else:
                # Error
                QMessageBox.critical(
                    self,
                    "Inference Failed",
                    f"Failed to submit inference request:\n\n{result}",
                )

        except Exception as e:
            self.progress_bar.setVisible(False)
            QMessageBox.critical(self, "Error", f"Error submitting inference request: {str(e)}")

    def load_models(self):
        """Manually load models when button is clicked"""
        api_key = self.api_key_input.text().strip()
        if not api_key:
            QMessageBox.warning(self, "Warning", "Please enter an API key first")
            return

        # Disable button and show loading state
        self.load_models_btn.setEnabled(False)
        self.load_models_btn.setText("Loading...")

        try:
            self.api_handler.set_auth_credentials(api_key, "X-Api-Key")
            success, result = self.api_handler.list_models()

            if success:
                self.models_list.clear()
                for model in result:
                    if isinstance(model, dict):
                        model_id = model.get("id", "")
                        model_name = model.get("display_name", "Unnamed Model")
                        display_text = f"{model_name} ({model_id})"

                        item = QtWidgets.QListWidgetItem(display_text)
                        item.setData(Qt.UserRole, model_id)
                        self.models_list.addItem(item)

                QMessageBox.information(self, "Success", f"Loaded {self.models_list.count()} models")

            else:
                self.models_list.clear()
                error_item = QtWidgets.QListWidgetItem(f"Error loading models: {result}")
                self.models_list.addItem(error_item)
                QMessageBox.warning(self, "Error", f"Failed to load models: {result}")

        except Exception as e:
            self.models_list.clear()
            error_item = QtWidgets.QListWidgetItem(f"Error: {str(e)}")
            self.models_list.addItem(error_item)
            QMessageBox.critical(self, "Error", f"Error loading models: {str(e)}")

        finally:
            # Re-enable button and restore text
            self.load_models_btn.setEnabled(True)
            self.load_models_btn.setText("Load Models")

    def on_api_key_changed(self):
        """Enable/disable load models button based on API key input"""
        api_key = self.api_key_input.text().strip()
        self.load_models_btn.setEnabled(bool(api_key))

    def get_location_from_bbox(self, bbox):
        """Get location from bounding box with city, state, country"""
        try:
            # Calculate center
            center_lon = (bbox[0] + bbox[2]) / 2
            center_lat = (bbox[1] + bbox[3]) / 2

            response = requests.get(
                "https://nominatim.openstreetmap.org/reverse",
                params={
                    "lat": center_lat,
                    "lon": center_lon,
                    "format": "json",
                    "addressdetails": 1,
                },
                headers={"User-Agent": "QGIS/1.0"},
                timeout=3,
            )

            if response.status_code == 200:
                data = response.json()
                address = data.get("address", {})

                location = []

                city = address.get("city") or address.get("town") or address.get("village") or address.get("hamlet")
                if city:
                    location.append(city)

                county = address.get("county")
                if county:
                    location.append(county)

                # Add state
                state = address.get("state") or address.get("region") or address.get("province")
                if state:
                    location.append(state)

                # Add country
                country = address.get("country")
                if country:
                    location.append(country)

                # Return formatted location or coordinates
                if location:
                    return ", ".join(location)
                else:
                    return f"{center_lat: .4f}, {center_lon: .4f}"

            return f"{center_lat: .4f}, {center_lon: .4f}"

        except Exception as e:  # noqa: F841
            # return coordinates on any error
            return f"{(bbox[1] + bbox[3]) / 2: .4f}, {(bbox[0] + bbox[2]) / 2: .4f}"

    def closeEvent(self, event):
        """
        Handles dialog close event.
        """
        event.accept()
