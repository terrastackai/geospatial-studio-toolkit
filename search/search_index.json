{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Welcome to the IBM Geospatial Exploration and Orchestration Studio SDK documentation!","text":""},{"location":"#installation","title":"Installation","text":"<p>First, set up your virtual development environment: <pre><code>python -m venv venv/\n\nsource venv/bin/activate\n</code></pre></p> <p>Install the SDK through pypi:</p> <pre><code>pip install geostudio\n</code></pre>"},{"location":"#usage","title":"Usage","text":"<ul> <li>After installing the SDK, obtain an API key.  Navigate to the UI front page and create an api key.  Click on the <code>Manage your API keys</code> link. This should pop-up a window where you can generate, access and delete your api keys.</li> </ul> <ul> <li> <p>Store the API key and geostudio ui base url in a credentials file locally, for example in /User/bob/.geostudio_config_file. You can do this by:     <pre><code>echo \"GEOSTUDIO_API_KEY=&lt;paste_api_key_here&gt;\" &gt; .geostudio_config_file &amp;&amp; echo \"BASE_STUDIO_UI_URL=&lt;paste_ui_base_url_here&gt;\" &gt;&gt; .geostudio_config_file\n</code></pre></p> </li> <li> <p>Connect to the Geospatial Studio SDK Client</p> <pre><code>from geostudio import Client\n\ngfm_client = Client(geostudio_config_file=\".geostudio_config_file\")\n</code></pre> </li> </ul>"},{"location":"#test-connection","title":"Test connection","text":"<p>Next, you can now use the gfm_client to make requests to the Geospatial studio api sevrice. The example below, uses the SDK client to list available models that we can run inference jobs against.</p> <pre><code>models = gfm_client.list_models()\n</code></pre> <p>For detailed examples on how to use the Geospatial studio SDK, please see the examples page</p>"},{"location":"api/","title":"API reference","text":""},{"location":"base_client/","title":"BaseClient","text":""},{"location":"base_client/#geostudio.backends.base_client","title":"geostudio.backends.base_client","text":""},{"location":"base_client/#geostudio.backends.base_client.BaseClient","title":"BaseClient","text":"<pre><code>BaseClient(api_config: GeoFmSettings = None, session: Session = None, api_token: str = None, api_key: str = None, api_key_file: str = None, geostudio_config_file: str = None, *args, **kwargs)\n</code></pre> <p>This class provides methods for making HTTP requests to a Geospatial studio APIs.</p> <p>Parameters:</p> Name Type Description Default <code>api_config</code> <code>GeoFmSettings</code> <p>The configuration settings for the GeoFm API. Defaults to None.</p> <code>None</code> <code>session</code> <code>Session</code> <p>A pre-configured requests session. Defaults to None.</p> <code>None</code> <code>api_token</code> <code>str</code> <p>The API token for authentication. Defaults to None.</p> <code>None</code> <code>api_key</code> <code>str</code> <p>The API key for authentication. Defaults to None.</p> <code>None</code> <code>api_key_file</code> <code>str</code> <p>The path to the file containing the API key. Defaults to None.</p> <code>None</code> <code>geostudio_config_file</code> <code>str</code> <p>The file path to the geostudio config path containing api_key + base_urls.</p> <code>None</code> <code>*args</code> <p>Variable length argument list.</p> <code>()</code> <code>**kwargs</code> <p>Arbitrary keyword arguments.</p> <code>{}</code> <p>Raises:</p> Type Description <code>GeoFMException</code> <p>If no API token, API key, or API key file is provided.</p> <p>Attributes:</p> Name Type Description <code>api_config</code> <code>GeoFmSettings</code> <p>The configuration settings for the GeoFm API.</p> <code>session</code> <code>Session</code> <p>A pre-configured requests session.</p> <code>logger</code> <code>Logger</code> <p>The logger instance for logging messages.</p> Subclassed by: <ul> <li> SDK Client <ul> <li> Client main Client </li> <li> Fine-tuning client Client </li> <li> Inference client Client </li> </ul> </li> </ul> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def __init__(\n    self,\n    api_config: GeoFmSettings = None,\n    session: requests.Session = None,\n    api_token: str = None,\n    api_key: str = None,\n    api_key_file: str = None,\n    geostudio_config_file: str = None,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initializes the GeoFmClient with the provided configuration.\n\n    Args:\n        api_config (GeoFmSettings, optional): The configuration settings for the GeoFm API. Defaults to None.\n        session (requests.Session, optional): A pre-configured requests session. Defaults to None.\n        api_token (str, optional): The API token for authentication. Defaults to None.\n        api_key (str, optional): The API key for authentication. Defaults to None.\n        api_key_file (str, optional): The path to the file containing the API key. Defaults to None.\n        geostudio_config_file (str): The file path to the geostudio config path containing api_key + base_urls.\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Raises:\n        GeoFMException: If no API token, API key, or API key file is provided.\n\n    Attributes:\n        api_config (GeoFmSettings): The configuration settings for the GeoFm API.\n        session (requests.Session): A pre-configured requests session.\n        logger (logging.Logger): The logger instance for logging messages.\n    \"\"\"\n    self.api_config = api_config or GeoFmSettings()\n\n    if api_token:\n        print(\"Using api_token\")\n        api_token = api_token or GeoFmSettings.GEOFM_API_TOKEN\n        self.session = gfm_session(access_token=api_token)\n    elif api_key:\n        print(\"Using api_key from sdk command\")\n        self.session = gfm_session(api_key=api_key)\n    elif api_key_file:\n        if not os.path.isfile(api_key_file):\n            raise GeoFMException(\"Config file does not exist, Please provide a valid config file.\")\n        print(\"Using api_key from file\")\n        self.session = gfm_session(api_key_file=api_key_file)\n    elif geostudio_config_file:\n        if not os.path.isfile(geostudio_config_file):\n            raise GeoFMException(\"Config file does not exist, Please provide a valid config file.\")\n        print(\"Using api key and base urls from geostudio config file\")\n        geostudio_config_file_values = dotenv_values(geostudio_config_file)\n        settings.BASE_GATEWAY_API_URL = geostudio_config_file_values.get(\"BASE_GATEWAY_API_URL\", \"\")\n        settings.BASE_STUDIO_UI_URL = geostudio_config_file_values.get(\"BASE_STUDIO_UI_URL\", \"\")\n        settings.GEOSTUDIO_API_KEY = geostudio_config_file_values.get(\"GEOSTUDIO_API_KEY\", None)\n        self.session = gfm_session(api_key=settings.GEOSTUDIO_API_KEY)\n    else:\n        raise GeoFMException(\"Missing APIToken. Add `GEOFM_API_TOKEN` to env variables.\")\n\n    # else:\n    #     self.session = session or gfm_session(\n    #         client_id=self.api_config.ISV_CLIENT_ID,\n    #         client_secret=self.api_config.ISV_CLIENT_SECRET,\n    #         well_known_url=self.api_config.ISV_WELL_KNOWN,\n    #         userinfo_endpoint=self.api_config.ISV_USER_ENDPOINT,\n    #     )\n    self.logger = logging.getLogger()\n</code></pre>"},{"location":"base_client/#geostudio.backends.base_client.BaseClient.api_url","title":"api_url  <code>property</code>","text":"<pre><code>api_url\n</code></pre> <p>Process both settings.BASE_GATEWAY_API_URL and settings.BASE_STUDIO_UI_URL 1. For both ensure they end with / 2. For settings.BASE_STUDIO_UI_URL it should only have one / and if there are others clip the rest of    the url after the first / e.g. https//myui.com/ 3. For settings.BASE_GATEWAY_API_URL it should have only one / if it does not have 2 / enclosing poxy    keyword. e.g. /proxy/ e.g. https//myapi.com/ or https//myapi.com/proxy/ otherwise clip the unwanted    parts of the url 4. In the function if settings.BASE_STUDIO_UI_URL is present return the processed UI_URL from 2 above    and only if settings.BASE_GATEWAY_API_URL is present return it after step 3</p>"},{"location":"base_client/#geostudio.backends.base_client.BaseClient.http_get","title":"http_get","text":"<pre><code>http_get(endpoint, owner=None, params=None, output=None, data_field=None)\n</code></pre> <p>Sends an HTTP GET request to the specified endpoint.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The endpoint to send the GET request to.</p> required <code>params</code> <code>dict</code> <p>Query parameters to include in the GET request.</p> <code>None</code> <code>output</code> <code>str</code> <p>The desired output format.</p> <code>None</code> <code>data_field</code> <code>str</code> <p>The name of the data field to extract from the response.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <p>The response data in the specified format.</p> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def http_get(self, endpoint, owner=None, params=None, output=None, data_field=None):\n    \"\"\"\n    Sends an HTTP GET request to the specified endpoint.\n\n    Parameters:\n        endpoint (str): The endpoint to send the GET request to.\n        params (dict, optional): Query parameters to include in the GET request.\n        output (str, optional): The desired output format.\n        data_field (str, optional): The name of the data field to extract from the response.\n\n    Returns:\n        object: The response data in the specified format.\n    \"\"\"\n    endpoint = parse.urljoin(self.api_url, endpoint)\n    # print(endpoint)\n    response = self.session.get(endpoint, params=params)\n    _check_auth_error(response=response)\n    if output == \"raw\":\n        return response\n    else:\n        return formated_output(response=response, output_fmt=output, data_field=data_field)\n</code></pre>"},{"location":"base_client/#geostudio.backends.base_client.BaseClient.http_post","title":"http_post","text":"<pre><code>http_post(endpoint, data, files: dict = None, output=None, data_field=None)\n</code></pre> <p>Sends an HTTP POST request to the specified endpoint with the given data.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The API endpoint to send the POST request to.</p> required <code>data</code> <code>dict</code> <p>The data to be sent in the POST request body.</p> required <code>output</code> <code>str</code> <p>The desired output format.</p> <code>None</code> <code>data_field</code> <code>str</code> <p>The key in the response JSON that contains the desired data.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <p>The response data in the specified format.</p> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def http_post(self, endpoint, data, files: dict = None, output=None, data_field=None):\n    \"\"\"\n    Sends an HTTP POST request to the specified endpoint with the given data.\n\n    Parameters:\n        endpoint (str): The API endpoint to send the POST request to.\n        data (dict): The data to be sent in the POST request body.\n        output (str, optional): The desired output format.\n        data_field (str, optional): The key in the response JSON that contains the desired data.\n\n    Returns:\n        object: The response data in the specified format.\n    \"\"\"\n    endpoint = parse.urljoin(self.api_url, endpoint)\n    if files:\n        self.session.headers.pop(\"Content-Type\")\n        response = self.session.post(endpoint, data=data, files=files)\n    else:\n        response = self.session.post(\n            endpoint,\n            data=json.dumps(data),\n        )\n    _check_auth_error(response=response)\n    return formated_output(response=response, output_fmt=output, data_field=data_field)\n</code></pre>"},{"location":"base_client/#geostudio.backends.base_client.BaseClient.http_put_file","title":"http_put_file","text":"<pre><code>http_put_file(endpoint, file_path, output=None, data_field=None)\n</code></pre> <p>Uploads a file to a specified endpoint using a PUT request.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The URL endpoint to send the PUT request to.</p> required <code>file_path</code> <code>str</code> <p>The path to the file to be uploaded.</p> required <code>output</code> <code>str</code> <p>The format of the response output. Default is None.</p> <code>None</code> <code>data_field</code> <code>str</code> <p>The field in the response to extract.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server in the specified output format.</p> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def http_put_file(self, endpoint, file_path, output=None, data_field=None):\n    \"\"\"\n    Uploads a file to a specified endpoint using a PUT request.\n\n    Parameters:\n        endpoint (str): The URL endpoint to send the PUT request to.\n        file_path (str): The path to the file to be uploaded.\n        output (str, optional): The format of the response output. Default is None.\n        data_field (str, optional): The field in the response to extract.\n\n    Returns:\n        dict: The response from the server in the specified output format.\n    \"\"\"\n    endpoint = parse.urljoin(self.api_url, endpoint)\n\n    with open(file_path, \"rb\") as file:\n        files = {\"file\": (file_path, file, \"application/x-yaml\")}\n        # Update file_headers to upload multipart/form-data\n        # file_headers = {\n        #     \"User-Agent\": \"python-requests/2.32.3\",\n        #     \"Accept-Encoding\": \"gzip, deflate\",\n        #     \"Accept\": \"*/*\",\n        #     \"Connection\": \"keep-alive\",\n        #     # \"Content-Type\": \"application/json\",\n        #     \"X-API-Key\": \"pak-M3B7oM4wtrC8lCxStRewwrewG3eayFI2\",\n        #     \"x-request-origin\": \"python-sdk/\",\n        # }\n\n        if \"Content-Type\" in self.session.headers:\n            self.session.headers.pop(\"Content-Type\")\n        response = self.session.put(url=endpoint, files=files)\n        # After updating, Return the headers to before adjusting them\n        self.session.headers[\"Content-Type\"] = \"application/json\"\n\n        return formated_output(response=response, output_fmt=output, data_field=data_field)\n</code></pre>"},{"location":"base_client/#geostudio.backends.base_client.BaseClient.http_put","title":"http_put","text":"<pre><code>http_put(endpoint, data, output=None, data_field=None, file_path=None)\n</code></pre> <p>Sends an HTTP PUT request to the specified endpoint with the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The URL endpoint to send the PUT request to.</p> required <code>data</code> <code>dict or str</code> <p>The data to be sent in the PUT request body. If a dictionary, it will be converted to JSON.</p> required <code>output</code> <code>str</code> <p>The desired output format.</p> <code>None</code> <code>data_field</code> <code>str</code> <p>The field in the response to extract.</p> <code>None</code> <code>file_path</code> <code>str</code> <p>If the data is a file path, the file will be read and sent as the request body.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The formatted response data based on the provided output format.</p> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def http_put(self, endpoint, data, output=None, data_field=None, file_path=None):\n    \"\"\"\n    Sends an HTTP PUT request to the specified endpoint with the provided data.\n\n    Parameters:\n        endpoint (str): The URL endpoint to send the PUT request to.\n        data (dict or str): The data to be sent in the PUT request body. If a dictionary, it will be converted to JSON.\n        output (str, optional): The desired output format.\n        data_field (str, optional): The field in the response to extract.\n        file_path (str, optional): If the data is a file path, the file will be read and sent as the request body.\n\n    Returns:\n        Any: The formatted response data based on the provided output format.\n    \"\"\"\n\n    endpoint = parse.urljoin(self.api_url, endpoint)\n    response = self.session.put(endpoint, data=json.dumps(data))\n    _check_auth_error(response=response)\n    return formated_output(response=response, output_fmt=output, data_field=data_field)\n</code></pre>"},{"location":"base_client/#geostudio.backends.base_client.BaseClient.http_patch","title":"http_patch","text":"<pre><code>http_patch(endpoint, data, output=None, data_field=None)\n</code></pre> <p>Sends a PATCH request to the specified endpoint with the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The URL endpoint to send the PATCH request to.</p> required <code>data</code> <code>dict</code> <p>The data to be sent in the body of the PATCH request.</p> required <code>output</code> <code>str</code> <p>The format of the response.</p> <code>None</code> <code>data_field</code> <code>str</code> <p>The field in the response to extract.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>Any</code> <p>The formatted response data, or the raw response if no output format is specified.</p> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def http_patch(self, endpoint, data, output=None, data_field=None):\n    \"\"\"\n    Sends a PATCH request to the specified endpoint with the provided data.\n\n    Parameters:\n        endpoint (str): The URL endpoint to send the PATCH request to.\n        data (dict): The data to be sent in the body of the PATCH request.\n        output (str, optional): The format of the response.\n        data_field (str, optional): The field in the response to extract.\n\n    Returns:\n        Any: The formatted response data, or the raw response if no output format is specified.\n    \"\"\"\n    endpoint = parse.urljoin(self.api_url, endpoint)\n    response = self.session.patch(endpoint, data=json.dumps(data))\n    _check_auth_error(response=response)\n    return formated_output(response=response, output_fmt=output, data_field=data_field)\n</code></pre>"},{"location":"base_client/#geostudio.backends.base_client.BaseClient.http_delete","title":"http_delete","text":"<pre><code>http_delete(endpoint, output=None, data_field=None)\n</code></pre> <p>Sends a DELETE request to the specified endpoint and returns the response.</p> <p>Parameters:</p> Name Type Description Default <code>endpoint</code> <code>str</code> <p>The URL endpoint to send the DELETE request to.</p> required <code>output</code> <code>str</code> <p>The format of the response.</p> <code>None</code> <code>data_field</code> <code>str</code> <p>The field in the response to extract.</p> <code>None</code> <p>Returns:</p> Name Type Description <code>object</code> <p>The response from the DELETE request, formatted according to the 'output' parameter.</p> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def http_delete(self, endpoint, output=None, data_field=None):\n    \"\"\"\n    Sends a DELETE request to the specified endpoint and returns the response.\n\n    Parameters:\n        endpoint (str): The URL endpoint to send the DELETE request to.\n        output (str, optional): The format of the response.\n        data_field (str, optional): The field in the response to extract.\n\n    Returns:\n        object: The response from the DELETE request, formatted according to the 'output' parameter.\n    \"\"\"\n    endpoint = parse.urljoin(self.api_url, endpoint)\n    response = self.session.delete(endpoint)\n    _check_auth_error(response=response)\n    return formated_output(response=response, output_fmt=output, data_field=data_field)\n</code></pre>"},{"location":"base_client/#geostudio.backends.base_client.ResponseFormats","title":"ResponseFormats","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p> <p>An enumeration representing the supported output formats.</p> <p>Attributes:</p> Name Type Description <code>JSON</code> <code>Dict[str, Any]</code> <p>\"json\"</p> <code>DATAFRAME</code> <code>DataFrame</code> <p>\"df\"</p> <code>RAW</code> <code>object</code> <p>\"raw\"</p>"},{"location":"base_client/#geostudio.backends.base_client.formated_output","title":"formated_output","text":"<pre><code>formated_output(response, output_fmt: str = JSON, data_field: str = None) -&gt; Union[DataFrame | Dict[str, Any | str]]\n</code></pre> <p>Formats the response data into the specified output format.</p> <p>Parameters:</p> Name Type Description Default <code>response</code> <code>Response</code> <p>The HTTP response object.</p> required <code>output_fmt</code> <code>str</code> <p>The desired output format. Defaults to ResponseFormats.JSON.</p> <code>JSON</code> <code>data_field</code> <code>str</code> <p>The specific data field to extract from the response. Defaults to None.</p> <code>None</code> <p>Returns:</p> Type Description <code>Union[DataFrame | Dict[str, Any | str]]</code> <p>dict or pd.DataFrame: The formatted response data.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If the specified output format is not supported.</p> <code>JSONDecodeError</code> <p>If the response cannot be parsed as JSON.</p> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def formated_output(\n    response, output_fmt: str = ResponseFormats.JSON, data_field: str = None\n) -&gt; Union[pd.DataFrame | Dict[str, Any | str]]:\n    \"\"\"\n    Formats the response data into the specified output format.\n\n    Parameters:\n        response (requests.Response): The HTTP response object.\n        output_fmt (str, optional): The desired output format. Defaults to ResponseFormats.JSON.\n        data_field (str, optional): The specific data field to extract from the response. Defaults to None.\n\n    Returns:\n        dict or pd.DataFrame: The formatted response data.\n\n    Raises:\n        ValueError: If the specified output format is not supported.\n        json.JSONDecodeError: If the response cannot be parsed as JSON.\n    \"\"\"\n    supported_formats = [s.value for s in ResponseFormats]\n    if output_fmt not in supported_formats:\n        raise ValueError(f\"Service `{output_fmt}` is not supported. Valid Options: {supported_formats}\")\n\n    try:\n        resp_data = response.json()\n        if resp_data.get(data_field):\n            resp_data = resp_data[data_field]\n    except json.JSONDecodeError:\n        return {\"reason\": response.text}\n\n    if output_fmt == ResponseFormats.JSON:\n        return response.json()\n    elif output_fmt == ResponseFormats.DATAFRAME:\n        if data_field:\n            df = pd.json_normalize(data=resp_data, sep=\".\", max_level=1)\n        else:\n            df = pd.json_normalize(data=resp_data, sep=\".\", max_level=1)\n        return df\n    elif output_fmt == ResponseFormats.RAW:\n        return response\n</code></pre>"},{"location":"client/","title":"Client","text":""},{"location":"client/#geostudio.backends.main","title":"geostudio.backends.main","text":""},{"location":"client/#geostudio.backends.main.Client","title":"Client","text":"<pre><code>Client(*args, **kwargs)\n</code></pre> <p>               Bases: <code>BaseClient</code></p> <p>A client for interacting with the Geospatial Studio APIs.</p> Example usage <pre><code>from geostudio import Client\ngfm_client = Client(api_key_file=\"/.geostudio_apikey\")\ngfm_client.list_apikeys()\n</code></pre> Source code in <code>geostudio/backends/main.py</code> <pre><code>def __init__(self, *args, **kwargs):\n    super().__init__(*args, **kwargs)\n    self.load_classes(*args, **kwargs)\n</code></pre>"},{"location":"client/#geostudio.backends.main.Client.load_classes","title":"load_classes","text":"<pre><code>load_classes(*args, **kwargs)\n</code></pre> <p>Dynamically load all classes from subpackages of geostudio.backends.v2</p> Source code in <code>geostudio/backends/main.py</code> <pre><code>def load_classes(self, *args, **kwargs):\n    \"\"\"Dynamically load all classes from subpackages of geostudio.backends.v2\"\"\"\n    package_path = Path(v2.__file__).parent\n    package_name = v2.__name__\n\n    for _, subpkg_name, is_pkg in pkgutil.iter_modules([str(package_path)]):\n        if not is_pkg:\n            continue\n\n        module_name = f\"{package_name}.{subpkg_name}.client\"\n        module = importlib.import_module(module_name)\n\n        if not hasattr(module, \"Client\"):\n            raise ImportError(f\"No Client class found in {module_name}\")\n\n        module_class = getattr(module, \"Client\")\n        instance = module_class(*args, **kwargs)\n\n        setattr(self, subpkg_name, instance)\n\n        for method_name, attr in module_class.__dict__.items():\n            if method_name.startswith(\"_\"):\n                continue\n            if isinstance(attr, property):\n                continue\n            method = getattr(instance, method_name)\n            if callable(method):\n                # bound_method = types.MethodType(method, self)\n                if hasattr(self, method_name):\n                    raise AttributeError(f\"Method conflict: {method_name} already exists\")\n                setattr(self, method_name, method)\n</code></pre>"},{"location":"client/#geostudio.backends.main.Client.list_apikeys","title":"list_apikeys","text":"<pre><code>list_apikeys(output: str = 'json')\n</code></pre> <p>Retrieves a list of API keys associated with the current user.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the list of API keys. The format depends on the 'output' parameter.</p> Source code in <code>geostudio/backends/main.py</code> <pre><code>def list_apikeys(self, output: str = \"json\"):\n    \"\"\"\n    Retrieves a list of API keys associated with the current user.\n\n    Args:\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing the list of API keys. The format depends on the 'output' parameter.\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/auth/api-keys\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"client/#geostudio.backends.main.Client.create_apikey","title":"create_apikey","text":"<pre><code>create_apikey(data: object = {}, output: str = 'json')\n</code></pre> <p>Creates a new API key.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing the data to be sent in the request body. Defaults to an empty dictionary.</p> <code>{}</code> <code>output</code> <code>str</code> <p>The desired output format. Can be either \"json\" or \"xml\". Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The created API key item</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If user already has 2 API keys registered.</p> Source code in <code>geostudio/backends/main.py</code> <pre><code>def create_apikey(self, data: object = {}, output: str = \"json\"):\n    \"\"\"\n    Creates a new API key.\n\n    Args:\n        data (dict, optional): A dictionary containing the data to be sent in the request body.\n            Defaults to an empty dictionary.\n        output (str, optional): The desired output format. Can be either \"json\" or \"xml\".\n            Defaults to \"json\".\n\n    Returns:\n        dict: The created API key item\n\n    Raises:\n        HTTPException: If user already has 2 API keys registered.\n    \"\"\"\n    response = self.http_post(f\"{self.api_version}/auth/api-keys\", data=data, output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"client/#geostudio.backends.main.Client.activate_apikey","title":"activate_apikey","text":"<pre><code>activate_apikey(apikey_id: str, data={'active': True}, output: str = 'json')\n</code></pre> <p>Activate and deactivate an API Key.</p> <p>Parameters:</p> Name Type Description Default <code>apikey_id</code> <code>str</code> <p>The ID of the API key to activate/deactivate.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A message of successful activation/deactivation.</p> Source code in <code>geostudio/backends/main.py</code> <pre><code>def activate_apikey(self, apikey_id: str, data={\"active\": True}, output: str = \"json\"):\n    \"\"\"\n    Activate and deactivate an API Key.\n\n    Args:\n        apikey_id (str): The ID of the API key to activate/deactivate.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A message of successful activation/deactivation.\n    \"\"\"\n    response = self.http_patch(\n        f\"{self.api_version}/auth/api-keys?apikey_id={apikey_id}\", data=data, output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"client/#geostudio.backends.main.Client.delete_apikey","title":"delete_apikey","text":"<pre><code>delete_apikey(apikey_id: str, output: str = 'json')\n</code></pre> <p>Deletes an API key by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>apikey_id</code> <code>str</code> <p>The ID of the API key to delete.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A message of successful deletion.</p> <p>Raises:</p> Type Description <code>HTTPException</code> <p>If the API Key does not exist.</p> Source code in <code>geostudio/backends/main.py</code> <pre><code>def delete_apikey(self, apikey_id: str, output: str = \"json\"):\n    \"\"\"\n    Deletes an API key by its ID.\n\n    Args:\n        apikey_id (str): The ID of the API key to delete.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A message of successful deletion.\n\n    Raises:\n        HTTPException: If the API Key does not exist.\n    \"\"\"\n    response = self.http_delete(\n        f\"{self.api_version}/auth/api-keys?apikey_id={apikey_id}\", output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"fine_tuning/","title":"Fine-tuning","text":""},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client","title":"geostudio.backends.v2.gtune.client","text":""},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client","title":"Client","text":"<pre><code>Client(api_config: GeoFmSettings = None, session: Session = None, api_token: str = None, api_key: str = None, api_key_file: str = None, geostudio_config_file: str = None, *args, **kwargs)\n</code></pre> <p>               Bases: <code>BaseClient</code></p> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def __init__(\n    self,\n    api_config: GeoFmSettings = None,\n    session: requests.Session = None,\n    api_token: str = None,\n    api_key: str = None,\n    api_key_file: str = None,\n    geostudio_config_file: str = None,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initializes the GeoFmClient with the provided configuration.\n\n    Args:\n        api_config (GeoFmSettings, optional): The configuration settings for the GeoFm API. Defaults to None.\n        session (requests.Session, optional): A pre-configured requests session. Defaults to None.\n        api_token (str, optional): The API token for authentication. Defaults to None.\n        api_key (str, optional): The API key for authentication. Defaults to None.\n        api_key_file (str, optional): The path to the file containing the API key. Defaults to None.\n        geostudio_config_file (str): The file path to the geostudio config path containing api_key + base_urls.\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Raises:\n        GeoFMException: If no API token, API key, or API key file is provided.\n\n    Attributes:\n        api_config (GeoFmSettings): The configuration settings for the GeoFm API.\n        session (requests.Session): A pre-configured requests session.\n        logger (logging.Logger): The logger instance for logging messages.\n    \"\"\"\n    self.api_config = api_config or GeoFmSettings()\n\n    if api_token:\n        print(\"Using api_token\")\n        api_token = api_token or GeoFmSettings.GEOFM_API_TOKEN\n        self.session = gfm_session(access_token=api_token)\n    elif api_key:\n        print(\"Using api_key from sdk command\")\n        self.session = gfm_session(api_key=api_key)\n    elif api_key_file:\n        if not os.path.isfile(api_key_file):\n            raise GeoFMException(\"Config file does not exist, Please provide a valid config file.\")\n        print(\"Using api_key from file\")\n        self.session = gfm_session(api_key_file=api_key_file)\n    elif geostudio_config_file:\n        if not os.path.isfile(geostudio_config_file):\n            raise GeoFMException(\"Config file does not exist, Please provide a valid config file.\")\n        print(\"Using api key and base urls from geostudio config file\")\n        geostudio_config_file_values = dotenv_values(geostudio_config_file)\n        settings.BASE_GATEWAY_API_URL = geostudio_config_file_values.get(\"BASE_GATEWAY_API_URL\", \"\")\n        settings.BASE_STUDIO_UI_URL = geostudio_config_file_values.get(\"BASE_STUDIO_UI_URL\", \"\")\n        settings.GEOSTUDIO_API_KEY = geostudio_config_file_values.get(\"GEOSTUDIO_API_KEY\", None)\n        self.session = gfm_session(api_key=settings.GEOSTUDIO_API_KEY)\n    else:\n        raise GeoFMException(\"Missing APIToken. Add `GEOFM_API_TOKEN` to env variables.\")\n\n    # else:\n    #     self.session = session or gfm_session(\n    #         client_id=self.api_config.ISV_CLIENT_ID,\n    #         client_secret=self.api_config.ISV_CLIENT_SECRET,\n    #         well_known_url=self.api_config.ISV_WELL_KNOWN,\n    #         userinfo_endpoint=self.api_config.ISV_USER_ENDPOINT,\n    #     )\n    self.logger = logging.getLogger()\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.list_tunes","title":"list_tunes","text":"<pre><code>list_tunes(output: str = 'json')\n</code></pre> <p>Lists all fine tuning jobs in the studio.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the list of tunes found.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def list_tunes(self, output: str = \"json\"):\n    \"\"\"\n    Lists all fine tuning jobs in the studio.\n\n    Args:\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing the list of tunes found.\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/tunes\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_tune","title":"get_tune","text":"<pre><code>get_tune(tune_id: str, output: str = 'json')\n</code></pre> <p>Retrieves a tune by ID. If the tune's status is Failed, a pre-signed url for the logs is generated.</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The unique identifier of the tune to retrieve.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The tune's status and information</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_tune(self, tune_id: str, output: str = \"json\"):\n    \"\"\"\n    Retrieves a tune by ID. If the tune's status is Failed, a pre-signed url for the logs is generated.\n\n    Parameters:\n        tune_id (str): The unique identifier of the tune to retrieve.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The tune's status and information\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/tunes/{tune_id}\", output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.update_tune","title":"update_tune","text":"<pre><code>update_tune(tune_id: str, data: TuneUpdateIn, output: str = 'json')\n</code></pre> <p>Update a tune in the database</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The unique identifier of the tune to be updated.</p> required <code>data</code> <code>TuneUpdateIn</code> <p>A dictionary containing the data to update for the tune.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of the updated tune.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def update_tune(self, tune_id: str, data: TuneUpdateIn, output: str = \"json\"):\n    \"\"\"\n    Update a tune in the database\n\n    Args:\n        tune_id (str): The unique identifier of the tune to be updated.\n        data (TuneUpdateIn): A dictionary containing the data to update for the tune.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary of the updated tune.\n    \"\"\"\n    payload = json.loads(TuneUpdateIn(**data).model_dump_json())\n    response = self.http_patch(f\"{self.api_version}/tunes/{tune_id}\", data=payload, output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.delete_tune","title":"delete_tune","text":"<pre><code>delete_tune(tune_id, output: str = 'json')\n</code></pre> <p>Deletes a specified tune using its ID.</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The ID of the tune to be deleted.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Message of successfully deleted tune</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def delete_tune(self, tune_id, output: str = \"json\"):\n    \"\"\"\n    Deletes a specified tune using its ID.\n\n    Args:\n        tune_id (str): The ID of the tune to be deleted.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: Message of successfully deleted tune\n    \"\"\"\n    response = self.http_delete(f\"{self.api_version}/tunes/{tune_id}\", output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.submit_tune","title":"submit_tune","text":"<pre><code>submit_tune(data: TuneSubmitIn, output: str = 'json')\n</code></pre> <p>Submit a fine-tuning job to the Geospatial studio platform</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TuneSubmitIn</code> <p>Parameters for the tuning job.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The server's response containing the submitted tune info.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def submit_tune(self, data: TuneSubmitIn, output: str = \"json\"):\n    \"\"\"\n    Submit a fine-tuning job to the Geospatial studio platform\n\n    Args:\n        data (TuneSubmitIn): Parameters for the tuning job.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The server's response containing the submitted tune info.\n    \"\"\"\n    data[\"name\"] = data[\"name\"].lower().replace(\" \", \"-\").replace(\"_\", \"-\")\n\n    payload = json.loads(TuneSubmitIn(**data).model_dump_json())\n    response = self.http_post(f\"{self.api_version}/submit-tune\", data=payload, output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.submit_hpo_tune","title":"submit_hpo_tune","text":"<pre><code>submit_hpo_tune(data: HpoTuneSubmitIn, output: str = 'json')\n</code></pre> <p>Submit a fine-tuning job with terratorch-iterate enabled.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>HpoTuneSubmitIn</code> <p>Parameters for the tuning job</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The server's response containing the submitted tune info.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def submit_hpo_tune(self, data: HpoTuneSubmitIn, output: str = \"json\"):\n    \"\"\"Submit a fine-tuning job with terratorch-iterate enabled.\n\n    Args:\n        data (HpoTuneSubmitIn): Parameters for the tuning job\n        output ( str, optional):  The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The server's response containing the submitted tune info.\n    \"\"\"\n    if isinstance(data, dict):\n        data = HpoTuneSubmitIn(**data)\n\n    if not os.path.isfile(data.config_file):\n        raise ValueError(f\"Config file not found: {data.config_file}\")\n    if os.path.getsize(data.config_file) == 0:\n        raise ValueError(f\"Config file is empty: {data.config_file}\")\n\n    filename = os.path.basename(data.config_file)\n    with open(data.config_file, \"rb\") as fobj:\n        config_content = fobj.read()\n\n    files = {\"config_file\": (filename, config_content, \"application/x-yaml\")}\n    payload = {\"tune_metadata\": data.tune_metadata.model_dump_json()}\n    response = self.http_post(\n        f\"{self.api_version}/submit-hpo-tune\",\n        data=payload,\n        files=files,\n        output=output,\n    )\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.upload_completed_tunes","title":"upload_completed_tunes","text":"<pre><code>upload_completed_tunes(data: UploadTuneInput)\n</code></pre> <p>Upload a completed fine-tuning job to the Geostudio platform</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>UploadTuneInput</code> <p>Parameters to update the tune with</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Message of successfully uploaded tune</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def upload_completed_tunes(self, data: UploadTuneInput):\n    \"\"\"\n    Upload a completed fine-tuning job to the Geostudio platform\n\n    Args:\n        data (UploadTuneInput): Parameters to update the tune with\n\n    Returns:\n        dict: Message of successfully uploaded tune\n    \"\"\"\n    payload = json.loads(UploadTuneInput(**data).model_dump_json())\n    response = self.http_post(f\"{self.api_version}/upload-completed-tunes\", data=payload, output=\"json\")\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.try_out_tune","title":"try_out_tune","text":"<pre><code>try_out_tune(tune_id: str, data: TryOutTuneInput)\n</code></pre> <p>Try-out inference on a tune without deploying the model.</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The unique identifier of the tune experiment.</p> required <code>data</code> <code>TryOutTuneInput</code> <p>The inference configurations to try the tune on</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary containing the details of the inference submitted.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def try_out_tune(self, tune_id: str, data: TryOutTuneInput):\n    \"\"\"Try-out inference on a tune without deploying the model.\n\n    Args:\n        tune_id (str): The unique identifier of the tune experiment.\n        data (TryOutTuneInput): The inference configurations to try the tune on\n\n    Returns:\n        dict: Dictionary containing the details of the inference submitted.\n    \"\"\"\n    payload = json.loads(TryOutTuneInput(**data).model_dump_json())\n    response = self.http_post(f\"{self.api_version}/tunes/{tune_id}/try-out\", data=payload, output=\"json\")\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.download_tune","title":"download_tune","text":"<pre><code>download_tune(tune_id: str, output: str = 'json')\n</code></pre> <p>Downloads a tuned model from the server.</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The unique identifier of the tuned model to download.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Dictionary with tune details including presigned urls to download the artifacts.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def download_tune(self, tune_id: str, output: str = \"json\"):\n    \"\"\"\n    Downloads a tuned model from the server.\n\n    Args:\n        tune_id (str): The unique identifier of the tuned model to download.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: Dictionary with tune details including presigned urls to download the artifacts.\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/tunes/{tune_id}/download\", output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_mlflow_metrics","title":"get_mlflow_metrics","text":"<pre><code>get_mlflow_metrics(tune_id: str, output: str = 'json')\n</code></pre> <p>Retrieves the MLflow URLs for the training and testing metrics of a given Tune experiment.</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The ID of the Tune experiment.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the MLflow URLs for the training and testing metrics. The dictionary will have the keys \"train_mlflow_url\" and \"test_mlflow_url\". If no metrics are found, the value for \"train_mlflow_url\" will be None.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_mlflow_metrics(self, tune_id: str, output: str = \"json\"):\n    \"\"\"\n    Retrieves the MLflow URLs for the training and testing metrics of a given Tune experiment.\n\n    Args:\n        tune_id (str): The ID of the Tune experiment.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing the MLflow URLs for the training and testing metrics.\n            The dictionary will have the keys \"train_mlflow_url\" and \"test_mlflow_url\".\n            If no metrics are found, the value for \"train_mlflow_url\" will be None.\n    \"\"\"\n    response = self.get_tune(tune_id)\n\n    ui_url_path = f\"{settings.BASE_STUDIO_UI_URL}mlflow/#\"\n    # Sample output [{'Train': '/experiments/exp_id/runs/run_id'}, {'Test': '/experiments/exp_id/runs/run_id'}]\n    train_path = None\n    test_path = None\n    try:\n        if response[\"metrics\"]:\n            merged = {k: v for d in response[\"metrics\"] for k, v in d.items()}\n            train_path = merged.get(\"Train\")\n            test_path = merged.get(\"Test\")\n\n            train_path = f\"{ui_url_path}{train_path}\"\n            if test_path:\n                test_path = f\"{ui_url_path}{test_path}\"\n\n            return {\"train_mlflow_url\": train_path, \"test_mlflow_url\": test_path}\n        else:\n            print(f\"No mlflow url found for {tune_id}\")\n\n    except Exception as e:\n        print(f\"Error getting metrics urls: {e} \")\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_tune_metrics","title":"get_tune_metrics","text":"<pre><code>get_tune_metrics(tune_id: str, output: str = 'json')\n</code></pre> <p>Retrieves the MLflow metrics for a specific tune.</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The unique identifier of the tune.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The metrics of the tune in the specified format.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_tune_metrics(self, tune_id: str, output: str = \"json\"):\n    \"\"\"\n    Retrieves the MLflow metrics for a specific tune.\n\n    Args:\n        tune_id (str): The unique identifier of the tune.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: The metrics of the tune in the specified format.\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/tunes/{tune_id}/metrics\", output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_tune_metrics_df","title":"get_tune_metrics_df","text":"<pre><code>get_tune_metrics_df(tune_id: str, run_name: str = 'Train')\n</code></pre> <p>Retrieves the MLflow metrics for a specific tune and displays them in a pandas DataFrame</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The unique identifier of the tune.</p> required <p>Returns:</p> Type Description <p>pd.DataFrame: A pandas DataFrame containing the tuning metrics.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_tune_metrics_df(self, tune_id: str, run_name: str = \"Train\"):\n    \"\"\"\n    Retrieves the MLflow metrics for a specific tune and displays them in a pandas DataFrame\n\n    Args:\n        tune_id (str): The unique identifier of the tune.\n\n    Returns:\n        pd.DataFrame: A pandas DataFrame containing the tuning metrics.\n\n    \"\"\"\n    m = self.get_tune_metrics(tune_id)\n    if not m.get(\"runs\"):\n        return pd.DataFrame()\n    run = next((run for run in m.get(\"runs\") if run.get(\"name\") == run_name), {})\n    if not run.get(\"metrics\"):\n        return pd.DataFrame()\n    mdf = pd.DataFrame.from_records(run[\"metrics\"][0])\n\n    for i in range(2, len(run[\"metrics\"])):\n        mdf_tmp = pd.DataFrame.from_records(run[\"metrics\"][i]).drop([\"epoch\"], axis=1)\n        mdf = pd.concat([mdf, mdf_tmp], axis=1)\n\n    mdf.sort_values([\"epoch\"], inplace=True)\n\n    return mdf\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.list_tuning_artefacts","title":"list_tuning_artefacts","text":"<pre><code>list_tuning_artefacts(tune_id: str)\n</code></pre> <p>Resolve the MLflow training run referenced by a tune and list artefact paths.</p> <p>This function: - Calls gfm_client.get_tune(tune_id) to obtain tune metadata that contains a     reference to the MLflow training run (expected under a metric named 'Train'). - Queries the MLflow server's artifacts list endpoint for that run to obtain     available artifact file paths.</p>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.list_tuning_artefacts--parameters","title":"Parameters","text":"<p>tune_id : str     Identifier of the tune (used to lookup metrics that contain the MLflow train run).</p>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.list_tuning_artefacts--returns","title":"Returns","text":"<p>tuple[list[str], str]     A tuple (art_files, train_run_id) where:     - art_files : list[str] \u2014 list of artifact paths returned by MLflow (from the         'files' array -&gt; each element's 'path').     - train_run_id : str \u2014 the resolved MLflow run id extracted from the tune metadata.</p>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.list_tuning_artefacts--notes","title":"Notes","text":"<ul> <li>The function expects the tune metadata (gfm_client.get_tune) to include a metric mapping containing a 'Train' entry whose value includes the MLflow run UUID (the run id is taken as the last path segment after splitting on '/').</li> <li>The MLflow artifacts list response is assumed to include a JSON 'files' array where each item has a 'path' key.</li> <li>Example:     art_files, run_id = list_tuning_artefacts('geotune-xxxxx', 'https://my-mlflow')</li> </ul> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def list_tuning_artefacts(self, tune_id: str):\n    \"\"\"\n    Resolve the MLflow training run referenced by a tune and list artefact paths.\n\n    This function:\n    - Calls gfm_client.get_tune(tune_id) to obtain tune metadata that contains a\n        reference to the MLflow training run (expected under a metric named 'Train').\n    - Queries the MLflow server's artifacts list endpoint for that run to obtain\n        available artifact file paths.\n\n    Parameters\n    ----------\n    tune_id : str\n        Identifier of the tune (used to lookup metrics that contain the MLflow train run).\n\n    Returns\n    -------\n    tuple[list[str], str]\n        A tuple (art_files, train_run_id) where:\n        - art_files : list[str] \u2014 list of artifact paths returned by MLflow (from the\n            'files' array -&gt; each element's 'path').\n        - train_run_id : str \u2014 the resolved MLflow run id extracted from the tune metadata.\n\n    Notes\n    -----\n    - The function expects the tune metadata (gfm_client.get_tune) to include a metric\n    mapping containing a 'Train' entry whose value includes the MLflow run UUID (the\n    run id is taken as the last path segment after splitting on '/').\n    - The MLflow artifacts list response is assumed to include a JSON 'files' array where\n    each item has a 'path' key.\n    - Example:\n        art_files, run_id = list_tuning_artefacts('geotune-xxxxx', 'https://my-mlflow')\n    \"\"\"\n\n    mlflow_url = f\"{'/'.join(self.api_url[:-1].split('/')[:-1])}/mlflow\"\n\n    tune_info = self.get_tune(tune_id)\n    train_run_id = {k: v for d in tune_info[\"metrics\"] for k, v in d.items()}[\"Train\"].split(\"/\")[-1]\n\n    # req = requests.get(f\"{mlflow_url}/api/2.0/mlflow/artifacts/list?run_id={train_run_id}\")\n    print(f\"{mlflow_url}/api/2.0/mlflow/artifacts/list?run_id={train_run_id}\")\n    req = self.http_get(f\"{mlflow_url}/api/2.0/mlflow/artifacts/list?run_id={train_run_id}\", output=\"json\")\n    art_list = req[\"files\"]\n    art_files = [X[\"path\"] for X in art_list]\n    print(f\"Found {len(art_files)} artefacts\")\n    return art_files, train_run_id\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_tuning_artefacts","title":"get_tuning_artefacts","text":"<pre><code>get_tuning_artefacts(tune_id: str, epochs: list = None, image_numbers: list = None)\n</code></pre> <p>Download fine\u2011tuning artefact images from an MLflow run referenced by a tune.</p> <p>This function: - Resolves the MLflow training run id for the given tune via gfm_client.get_tune(...) - Lists artefacts for that run from the MLflow server - Optionally filters artefact filenames by epoch and/or image number - Downloads matching artefacts in parallel and returns a list of records</p>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_tuning_artefacts--parameters","title":"Parameters","text":"<p>tune_id : str     Identifier of the tune (used to lookup metrics that contain the MLflow train run). epochs : list[int], optional     If provided, only artefacts whose filename encodes an epoch contained in this list     are retained. Filenames are assumed to contain epoch as the second underscore-separated     token (e.g. \"epoch_4_5.png\" -&gt; epoch 4). image_numbers : list[int], optional     If provided, only artefacts whose filename encodes an image number contained in this     list are retained. Filenames are assumed to contain the image number as the third     underscore-separated token (e.g. \"epoch_4_5.png\" -&gt; image_number 5).</p>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_tuning_artefacts--returns","title":"Returns","text":"<p>list[dict]     A list of dictionaries, one per downloaded artefact, with keys:     - 'filename' (str): artefact path from MLflow     - 'image' (bytes): raw downloaded bytes     - 'epoch' (int): parsed epoch number     - 'image_number' (int): parsed image/sample number</p>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_tuning_artefacts--notes","title":"Notes","text":"<ul> <li>Downloads are performed in parallel using joblib (threads).</li> <li>The function assumes artefact filenames follow the pattern containing \"epoch__.\". Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_tuning_artefacts(self, tune_id: str, epochs: list = None, image_numbers: list = None):\n    \"\"\"\n    Download fine\u2011tuning artefact images from an MLflow run referenced by a tune.\n\n    This function:\n    - Resolves the MLflow training run id for the given tune via gfm_client.get_tune(...)\n    - Lists artefacts for that run from the MLflow server\n    - Optionally filters artefact filenames by epoch and/or image number\n    - Downloads matching artefacts in parallel and returns a list of records\n\n    Parameters\n    ----------\n    tune_id : str\n        Identifier of the tune (used to lookup metrics that contain the MLflow train run).\n    epochs : list[int], optional\n        If provided, only artefacts whose filename encodes an epoch contained in this list\n        are retained. Filenames are assumed to contain epoch as the second underscore-separated\n        token (e.g. \"epoch_4_5.png\" -&gt; epoch 4).\n    image_numbers : list[int], optional\n        If provided, only artefacts whose filename encodes an image number contained in this\n        list are retained. Filenames are assumed to contain the image number as the third\n        underscore-separated token (e.g. \"epoch_4_5.png\" -&gt; image_number 5).\n\n    Returns\n    -------\n    list[dict]\n        A list of dictionaries, one per downloaded artefact, with keys:\n        - 'filename' (str): artefact path from MLflow\n        - 'image' (bytes): raw downloaded bytes\n        - 'epoch' (int): parsed epoch number\n        - 'image_number' (int): parsed image/sample number\n\n    Notes\n    -----\n    - Downloads are performed in parallel using joblib (threads).\n    - The function assumes artefact filenames follow the pattern containing\n    \"epoch_&lt;epoch&gt;_&lt;image_number&gt;.&lt;ext&gt;\".\n    \"\"\"\n\n    requests.packages.urllib3.disable_warnings()\n    art_files, train_run_id = self.list_tuning_artefacts(tune_id)\n\n    if epochs is not None:\n        art_files = [X for X in art_files if int(X.split(\"_\")[1]) in epochs]\n    if image_numbers is not None:\n        art_files = [X for X in art_files if int(X.split(\"_\")[2].split(\".\")[0]) in image_numbers]\n\n    print(f\"Downloading {len(art_files)} artefacts...\")\n\n    ans = list(\n        track(\n            Parallel(n_jobs=10, prefer=\"threads\")(\n                delayed(self.get_training_image)(fn, train_run_id) for fn in art_files\n            ),\n            total=len(art_files),\n        )\n    )\n\n    print(\"Downloaded all artefacts\")\n    img_dict = [\n        {\n            \"filename\": art_files[X],\n            \"image\": ans[X],\n            \"epoch\": int(art_files[X].split(\"_\")[1]),\n            \"image_number\": int(art_files[X].split(\"_\")[2].split(\".\")[0]),\n        }\n        for X in range(0, len(art_files))\n    ]\n\n    return img_dict\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.list_tune_templates","title":"list_tune_templates","text":"<pre><code>list_tune_templates(output: str = 'json')\n</code></pre> <p>Lists tune templates studio.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the list of tune templates in the studio</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def list_tune_templates(self, output: str = \"json\"):\n    \"\"\"\n    Lists tune templates studio.\n\n    Args:\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing the list of tune templates in the studio\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/tune-templates\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.create_task","title":"create_task","text":"<pre><code>create_task(data: TaskIn, output: str = 'json')\n</code></pre> <p>Creates a new task using the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>TaskIn</code> <p>The data required to create a new task.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server containing the details of the newly created task.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def create_task(self, data: TaskIn, output: str = \"json\"):\n    \"\"\"\n    Creates a new task using the provided data.\n\n    Args:\n        data (TaskIn): The data required to create a new task.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The response from the server containing the details of the newly created task.\n    \"\"\"\n    response = self.http_post(f\"{self.api_version}/tune-templates\", data=data, output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_task","title":"get_task","text":"<pre><code>get_task(task_id: str, output: str = 'json')\n</code></pre> <p>Retrieves a task by its ID.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to retrieve.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server containing the task details.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_task(self, task_id: str, output: str = \"json\"):\n    \"\"\"\n    Retrieves a task by its ID.\n\n    Args:\n        task_id (str): The ID of the task to retrieve.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: The response from the server containing the task details.\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/tune-templates/{task_id}\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.delete_task","title":"delete_task","text":"<pre><code>delete_task(task_id, output: str = 'json')\n</code></pre> <p>Deletes a task with the given task_id.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The unique identifier of the task to be deleted.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Message of successfully deleted task.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def delete_task(self, task_id, output: str = \"json\"):\n    \"\"\"\n    Deletes a task with the given task_id.\n\n    Args:\n        task_id (str): The unique identifier of the task to be deleted.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: Message of successfully deleted task.\n\n    \"\"\"\n    response = self.http_delete(f\"{self.api_version}/tune-templates/{task_id}\", output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_task_template","title":"get_task_template","text":"<pre><code>get_task_template(task_id: str, output: str = 'text')\n</code></pre> <p>Retrieves the task template yaml for the selected task</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to retrieve.</p> required <code>output</code> <code>str</code> <p>The format of the response. Can either be \"cell\", \"text\" or \"file\".</p> <code>'text'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server containing the task template yaml.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_task_template(self, task_id: str, output: str = \"text\"):\n    \"\"\"\n    Retrieves the task template yaml for the selected task\n\n    Args:\n        task_id (str): The ID of the task to retrieve.\n        output (str, optional): The format of the response. Can either be \"cell\", \"text\" or \"file\".\n\n    Returns:\n        dict: The response from the server containing the task template yaml.\n    \"\"\"\n    response = self.http_get(\n        f\"{self.api_version}/tune-templates/{task_id}/template\", output=\"json\", data_field=\"results\"\n    )\n    if output == \"text\":\n        return response[\"reason\"]\n    elif output == \"cell\":\n        create_new_cell(f\"ty = '''{response['reason']}''' \")\n    elif output == \"file\":\n        with open(task_id + \".yaml\", \"w\") as fp:\n            fp.write(response[\"reason\"])\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.update_task","title":"update_task","text":"<pre><code>update_task(task_id: str, file_path: str, output: str = 'json')\n</code></pre> <p>Updates a task's content with a yaml file config</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to upload.</p> required <code>file_path</code> <code>str</code> <p>The path to the file containing the new template.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Message of successful task upload</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def update_task(self, task_id: str, file_path: str, output: str = \"json\"):\n    \"\"\"\n    Updates a task's content with a yaml file config\n\n    Args:\n        task_id (str): The ID of the task to upload.\n        file_path (str): The path to the file containing the new template.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: Message of successful task upload\n    \"\"\"\n\n    response = self.http_put_file(\n        f\"{self.api_version}/tune-templates/{task_id}/template\", file_path=file_path, output=output\n    )\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.update_task_schema","title":"update_task_schema","text":"<pre><code>update_task_schema(task_id: str, task_schema: Any, output: str = 'json')\n</code></pre> <p>Update the JSONSchema of a task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to update.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Message of successful task update</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def update_task_schema(self, task_id: str, task_schema: Any, output: str = \"json\"):\n    \"\"\"\n    Update the JSONSchema of a task.\n\n    Args:\n        task_id (str): The ID of the task to update.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: Message of successful task update\n    \"\"\"\n\n    response = self.http_put(f\"{self.api_version}/tune-templates/{task_id}/schema\", data=task_schema, output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_task_param_defaults","title":"get_task_param_defaults","text":"<pre><code>get_task_param_defaults(task_id: str)\n</code></pre> <p>Retrieves the default parameter values for a given task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The unique identifier of the task.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the default parameter values for the task. The keys are the parameter names and the values are the default values.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_task_param_defaults(self, task_id: str):\n    \"\"\"\n    Retrieves the default parameter values for a given task.\n\n    Args:\n        task_id (str): The unique identifier of the task.\n\n    Returns:\n        dict: A dictionary containing the default parameter values for the task.\n            The keys are the parameter names and the values are the default values.\n    \"\"\"\n    task_meta = self.get_task(task_id)\n    defaults_dict = {}\n    for k in task_meta[\"model_params\"][\"properties\"].keys():\n        if \"properties\" in task_meta[\"model_params\"][\"properties\"][k]:\n            defaults_dict[k] = task_meta[\"model_params\"][\"properties\"][k][\"default\"]\n    return defaults_dict\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.check_task_content","title":"check_task_content","text":"<pre><code>check_task_content(task_id: str, dataset_id: str, base_model_id: Any, output: str = 'text')\n</code></pre> <p>Checks that the the task renders correctly</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to check.</p> required <code>output</code> <code>str</code> <p>The format of the returned template. Can be \"text\", \"cell\", or \"file\". Defaults to \"text\".</p> <code>'text'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Message of task content</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def check_task_content(self, task_id: str, dataset_id: str, base_model_id: Any, output: str = \"text\"):\n    \"\"\"\n    Checks that the the task renders correctly\n\n    Args:\n        task_id (str): The ID of the task to check.\n        output (str, optional): The format of the returned template. Can be \"text\", \"cell\", or \"file\". Defaults to \"text\".\n\n    Returns:\n        dict: Message of task content\n    \"\"\"\n    params = {\"dataset_id\": dataset_id, \"base_model\": base_model_id}\n    response = self.http_get(\n        f\"{self.api_version}/tune-templates/{task_id}/test-render\", params=params, output=\"json\"\n    )\n    if output == \"text\":\n        return response[\"reason\"]\n    elif output == \"cell\":\n        create_new_cell(f\"ty = '''{response['reason']}''' \")\n    elif output == \"file\":\n        with open(task_id + \".yaml\", \"w\") as fp:\n            fp.write(response[\"reason\"])\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.render_template","title":"render_template","text":"<pre><code>render_template(task_id: str, dataset_id: str, output: str = 'text')\n</code></pre> <p>Checks that the the user defined task renders correctly.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>str</code> <p>The ID of the task to check.</p> required <code>dataset_id</code> <code>str</code> <p>The ID of the dataset associated with the task.</p> required <code>output</code> <code>str</code> <p>The format of the returned template. Can be \"text\", \"cell\", or \"file\". Defaults to \"text\".</p> <code>'text'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The rendered template in the specified output format.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def render_template(self, task_id: str, dataset_id: str, output: str = \"text\"):\n    \"\"\"\n    Checks that the the user defined task renders correctly.\n\n    Args:\n        task_id (str): The ID of the task to check.\n        dataset_id (str): The ID of the dataset associated with the task.\n        output (str, optional): The format of the returned template. Can be \"text\", \"cell\", or \"file\". Defaults to \"text\".\n\n    Returns:\n        dict: The rendered template in the specified output format.\n    \"\"\"\n    t_params = {\"dataset_id\": dataset_id}\n    response = self.http_get(\n        f\"{self.api_version}/tune-templates/{task_id}/test-render-user-defined-task\", params=t_params, output=\"json\"\n    )\n    if output == \"text\":\n        return response[\"reason\"]\n    elif output == \"cell\":\n        create_new_cell(f\"ty = '''{response['reason']}''' \")\n    elif output == \"file\":\n        with open(task_id + \".yaml\", \"w\") as fp:\n            fp.write(response[\"reason\"])\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.list_datasets","title":"list_datasets","text":"<pre><code>list_datasets(output: str = 'json')\n</code></pre> <p>Lists all datasets available in the studio.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing a list of datasets found in the dataset factory</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def list_datasets(self, output: str = \"json\"):\n    \"\"\"\n    Lists all datasets available in the studio.\n\n    Parameters:\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing a list of datasets found in the dataset factory\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/datasets\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.pre_scan_dataset","title":"pre_scan_dataset","text":"<pre><code>pre_scan_dataset(data: PreScanDatasetIn, output: str = 'json')\n</code></pre> <p>Scans a new dataset - checks accessibility of the dataset URL, ensures corresponding data and label files are present, and extracts bands and their descriptions from the dataset.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>PreScanDatasetIn</code> <p>Link to the dataset to scan</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the scan results.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def pre_scan_dataset(self, data: PreScanDatasetIn, output: str = \"json\"):\n    \"\"\"\n    Scans a new dataset - checks accessibility of the dataset URL, ensures corresponding data and label files are present, and extracts bands and their descriptions from the dataset.\n\n    Args:\n        data (PreScanDatasetIn): Link to the dataset to scan\n\n    Returns:\n        dict: A dictionary containing the scan results.\n    \"\"\"\n    payload = json.loads(PreScanDatasetIn(**data).model_dump_json())\n    response = self.http_post(f\"{self.api_version}/datasets/pre-scan\", data=payload, output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_sample_images","title":"get_sample_images","text":"<pre><code>get_sample_images(dataset_id: str, output: str = 'json')\n</code></pre> <p>Retrieves a sample of images from a specified dataset.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The unique identifier of the dataset.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the sample data in the requested format.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_sample_images(self, dataset_id: str, output: str = \"json\"):\n    \"\"\"\n    Retrieves a sample of images from a specified dataset.\n\n    Args:\n        dataset_id (str): The unique identifier of the dataset.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing the sample data in the requested format.\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/datasets/{dataset_id}/sample\", output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.update_dataset","title":"update_dataset","text":"<pre><code>update_dataset(dataset_id: str, data: DatasetUpdateIn, output: str = 'json')\n</code></pre> <p>Update a dataset metadata in the database</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The unique identifier of the dataset to be updated.</p> required <code>data</code> <code>DatasetUpdateIn</code> <p>A dictionary containing the data to update for the dataset.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary of the updated dataset.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def update_dataset(self, dataset_id: str, data: DatasetUpdateIn, output: str = \"json\"):\n    \"\"\"\n    Update a dataset metadata in the database\n\n    Args:\n        dataset_id (str): The unique identifier of the dataset to be updated.\n        data (DatasetUpdateIn): A dictionary containing the data to update for the dataset.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary of the updated dataset.\n    \"\"\"\n    payload = json.loads(DatasetUpdateIn(**data).model_dump_json())\n    response = self.http_patch(f\"{self.api_version}/datasets/{dataset_id}\", data=payload, output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_dataset","title":"get_dataset","text":"<pre><code>get_dataset(dataset_id: str, output: str = 'json')\n</code></pre> <p>Retrieves a dataset from the studio.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The unique identifier of the dataset to retrieve.</p> required <code>output</code> <code>str</code> <p>The format of the response. Default is \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Information about the dataset found.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_dataset(self, dataset_id: str, output: str = \"json\"):\n    \"\"\"\n    Retrieves a dataset from the studio.\n\n    Parameters:\n        dataset_id (str): The unique identifier of the dataset to retrieve.\n        output (str, optional): The format of the response. Default is \"json\".\n\n    Returns:\n        dict: Information about the dataset found.\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/datasets/{dataset_id}\", output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.delete_dataset","title":"delete_dataset","text":"<pre><code>delete_dataset(dataset_id: str, output: str = 'json')\n</code></pre> <p>Deletes a dataset with the given ID.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The ID of the dataset to delete.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary with a message after dataset is deleted</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def delete_dataset(self, dataset_id: str, output: str = \"json\"):\n    \"\"\"\n    Deletes a dataset with the given ID.\n\n    Args:\n        dataset_id (str): The ID of the dataset to delete.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary with a message after dataset is deleted\n    \"\"\"\n    response = self.http_delete(f\"{self.api_version}/datasets/{dataset_id}\", output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.onboard_dataset","title":"onboard_dataset","text":"<pre><code>onboard_dataset(data: DatasetOnboardIn, output: str = 'json')\n</code></pre> <p>Onboards a new dataset to the Geospatial studio.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>DatasetOnboardIn</code> <p>The dataset information to be onboarded.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing information about the onboarded dataset.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def onboard_dataset(self, data: DatasetOnboardIn, output: str = \"json\"):\n    \"\"\"\n    Onboards a new dataset to the Geospatial studio.\n\n    Args:\n        data (DatasetOnboardIn): The dataset information to be onboarded.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing information about the onboarded dataset.\n    \"\"\"\n    payload = json.loads(DatasetOnboardIn(**data).model_dump_json())\n    response = self.http_post(f\"{self.api_version}/datasets/onboard\", data=payload, output=output)\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.list_base_models","title":"list_base_models","text":"<pre><code>list_base_models(output: str = 'json')\n</code></pre> <p>Lists all available base foundation models.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing a list of base foundation models available in the studio</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def list_base_models(self, output: str = \"json\"):\n    \"\"\"\n    Lists all available base foundation models.\n\n    Parameters:\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing a list of base foundation models available in the studio\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/base-models\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.create_base_model","title":"create_base_model","text":"<pre><code>create_base_model(data: BaseModelsIn, output: str = 'json')\n</code></pre> <p>Create a base foundation model in the Studio.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <code>data</code> <code>BaseModelsIn</code> <p>Parameters for creating the base model.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing a list of base foundation models available in the studio</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def create_base_model(self, data: BaseModelsIn, output: str = \"json\"):\n    \"\"\"\n    Create a base foundation model in the Studio.\n\n    Parameters:\n        output (str, optional): The format of the response. Defaults to \"json\".\n        data (BaseModelsIn): Parameters for creating the base model.\n\n    Returns:\n        dict: A dictionary containing a list of base foundation models available in the studio\n    \"\"\"\n    response = self.http_post(f\"{self.api_version}/base-models\", data=data, output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.get_base_model","title":"get_base_model","text":"<pre><code>get_base_model(base_id: str, output: str = 'json')\n</code></pre> <p>Get base foundation model by id.</p> <p>Parameters:</p> Name Type Description Default <code>base_id</code> <code>str</code> <p>Base model ID</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The Found base model</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def get_base_model(self, base_id: str, output: str = \"json\"):\n    \"\"\"\n    Get base foundation model by id.\n\n    Parameters:\n        base_id (str): Base model ID\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: The Found base model\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/base-models/{base_id}\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.update_base_model_params","title":"update_base_model_params","text":"<pre><code>update_base_model_params(base_id: str, data: BaseModelParamsIn, output: str = 'json')\n</code></pre> <p>Update base foundation model params.</p> <p>Parameters:</p> Name Type Description Default <code>base_id</code> <code>str</code> <p>Base model ID.</p> required <code>data</code> <code>BaseModelParamsIn</code> <p>Base model params to update.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>Updates Base model params</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def update_base_model_params(self, base_id: str, data: BaseModelParamsIn, output: str = \"json\"):\n    \"\"\"\n    Update base foundation model params.\n\n    Parameters:\n        base_id (str): Base model ID.\n        data (BaseModelParamsIn): Base model params to update.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: Updates Base model params\n    \"\"\"\n    response = self.http_patch(\n        f\"{self.api_version}/base-models/{base_id}/model-params\", data=data, output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.poll_onboard_dataset_until_finished","title":"poll_onboard_dataset_until_finished","text":"<pre><code>poll_onboard_dataset_until_finished(dataset_id, poll_frequency=10)\n</code></pre> <p>Polls the status of an onboard dataset until it finishes processing. Defaults to a minimum of 5seconds poll frequency.</p> <p>Parameters:</p> Name Type Description Default <code>dataset_id</code> <code>str</code> <p>The unique identifier of the dataset being onboarded.</p> required <code>poll_frequency</code> <code>int</code> <p>The time interval in seconds between polls. Defaults to 5 seconds.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The final status of the dataset, either \"Succeeded\" or \"Failed\".</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def poll_onboard_dataset_until_finished(self, dataset_id, poll_frequency=10):\n    \"\"\"\n    Polls the status of an onboard dataset until it finishes processing.\n    Defaults to a minimum of 5seconds poll frequency.\n\n    Args:\n        dataset_id (str): The unique identifier of the dataset being onboarded.\n        poll_frequency (int, optional): The time interval in seconds between polls. Defaults to 5 seconds.\n\n    Returns:\n        dict: The final status of the dataset, either \"Succeeded\" or \"Failed\".\n    \"\"\"\n    # Default to a minimum of 10 seconds poll frequency.\n    poll_frequency = 10 if poll_frequency &lt; 10 else poll_frequency\n    finished = False\n\n    while finished is False:\n        r = self.get_dataset(dataset_id)\n        status = r[\"status\"]\n        time_taken = (\n            datetime.now(timezone.utc)\n            - datetime.strptime(r[\"created_at\"], \"%Y-%m-%dT%H:%M:%S.%f%z\").replace(tzinfo=timezone.utc)\n        ).seconds\n\n        if status == \"Succeeded\":\n            print(status + \" - \" + str(time_taken) + \" seconds\")\n            finished = True\n            return r\n\n        elif status == \"Failed\":\n            print(status + \" - \" + str(time_taken) + \" seconds\")\n            finished = True\n            return r\n\n        else:\n            print(status + \" - \" + str(time_taken) + \" seconds\", end=\"\\r\")\n\n        sleep(poll_frequency)\n</code></pre>"},{"location":"fine_tuning/#geostudio.backends.v2.gtune.client.Client.poll_finetuning_until_finished","title":"poll_finetuning_until_finished","text":"<pre><code>poll_finetuning_until_finished(tune_id, poll_frequency=10)\n</code></pre> <p>Polls the status of a tune until it finishes or fails.</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The unique identifier of the tune to poll.</p> required <code>poll_frequency</code> <code>int</code> <p>The time interval in seconds between polls. Defaults to 5 seconds.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The final status of the tune, including details such as the number of epochs and any error messages if the tune failed.</p> Source code in <code>geostudio/backends/v2/gtune/client.py</code> <pre><code>def poll_finetuning_until_finished(self, tune_id, poll_frequency=10):\n    \"\"\"\n    Polls the status of a tune until it finishes or fails.\n\n    Args:\n        tune_id (str): The unique identifier of the tune to poll.\n        poll_frequency (int, optional): The time interval in seconds between polls. Defaults to 5 seconds.\n\n    Returns:\n        dict: The final status of the tune, including details such as the number of epochs and any error messages if the tune failed.\n    \"\"\"\n    # Default to a minimum of 10 seconds poll frequency.\n    poll_frequency = 10 if poll_frequency &lt; 10 else poll_frequency\n    finished = False\n\n    while finished is False:\n        r = self.get_tune(tune_id)\n        status = r[\"status\"]\n        time_taken = (\n            datetime.now(timezone.utc)\n            - datetime.strptime(r[\"created_at\"], \"%Y-%m-%dT%H:%M:%S.%fZ\").replace(tzinfo=timezone.utc)\n        ).seconds\n\n        try:\n            m = self.get_tune_metrics(tune_id)\n            m_epochs = m.get(\"epochs\")\n        except Exception:\n            m_epochs = \"Unknown\"\n\n        if status == \"Finished\":\n            print(status + \" - Epoch: \" + str(m_epochs) + \" - \" + str(time_taken) + \" seconds\")\n            finished = True\n            return r\n\n        elif status == \"Failed\":\n            print(status + \" - Epoch: \" + str(m_epochs) + \" - \" + str(time_taken) + \" seconds\")\n            print(\"Download the logs from the link below:\")\n            print(r[\"logs_presigned_url\"])\n            finished = True\n            return r\n\n        else:\n            print(status + \" - Epoch: \" + str(m_epochs) + \" - \" + str(time_taken) + \" seconds\", end=\"\\r\")\n\n        sleep(poll_frequency)\n</code></pre>"},{"location":"inference/","title":"Inference","text":""},{"location":"inference/#geostudio.backends.v2.ginference.client","title":"geostudio.backends.v2.ginference.client","text":""},{"location":"inference/#geostudio.backends.v2.ginference.client.Client","title":"Client","text":"<pre><code>Client(api_config: GeoFmSettings = None, session: Session = None, api_token: str = None, api_key: str = None, api_key_file: str = None, geostudio_config_file: str = None, *args, **kwargs)\n</code></pre> <p>               Bases: <code>BaseClient</code></p> <p>A client for interacting with the Geospatial Studio inference API endpoints</p> Source code in <code>geostudio/backends/base_client.py</code> <pre><code>def __init__(\n    self,\n    api_config: GeoFmSettings = None,\n    session: requests.Session = None,\n    api_token: str = None,\n    api_key: str = None,\n    api_key_file: str = None,\n    geostudio_config_file: str = None,\n    *args,\n    **kwargs,\n):\n    \"\"\"\n    Initializes the GeoFmClient with the provided configuration.\n\n    Args:\n        api_config (GeoFmSettings, optional): The configuration settings for the GeoFm API. Defaults to None.\n        session (requests.Session, optional): A pre-configured requests session. Defaults to None.\n        api_token (str, optional): The API token for authentication. Defaults to None.\n        api_key (str, optional): The API key for authentication. Defaults to None.\n        api_key_file (str, optional): The path to the file containing the API key. Defaults to None.\n        geostudio_config_file (str): The file path to the geostudio config path containing api_key + base_urls.\n        *args: Variable length argument list.\n        **kwargs: Arbitrary keyword arguments.\n\n    Raises:\n        GeoFMException: If no API token, API key, or API key file is provided.\n\n    Attributes:\n        api_config (GeoFmSettings): The configuration settings for the GeoFm API.\n        session (requests.Session): A pre-configured requests session.\n        logger (logging.Logger): The logger instance for logging messages.\n    \"\"\"\n    self.api_config = api_config or GeoFmSettings()\n\n    if api_token:\n        print(\"Using api_token\")\n        api_token = api_token or GeoFmSettings.GEOFM_API_TOKEN\n        self.session = gfm_session(access_token=api_token)\n    elif api_key:\n        print(\"Using api_key from sdk command\")\n        self.session = gfm_session(api_key=api_key)\n    elif api_key_file:\n        if not os.path.isfile(api_key_file):\n            raise GeoFMException(\"Config file does not exist, Please provide a valid config file.\")\n        print(\"Using api_key from file\")\n        self.session = gfm_session(api_key_file=api_key_file)\n    elif geostudio_config_file:\n        if not os.path.isfile(geostudio_config_file):\n            raise GeoFMException(\"Config file does not exist, Please provide a valid config file.\")\n        print(\"Using api key and base urls from geostudio config file\")\n        geostudio_config_file_values = dotenv_values(geostudio_config_file)\n        settings.BASE_GATEWAY_API_URL = geostudio_config_file_values.get(\"BASE_GATEWAY_API_URL\", \"\")\n        settings.BASE_STUDIO_UI_URL = geostudio_config_file_values.get(\"BASE_STUDIO_UI_URL\", \"\")\n        settings.GEOSTUDIO_API_KEY = geostudio_config_file_values.get(\"GEOSTUDIO_API_KEY\", None)\n        self.session = gfm_session(api_key=settings.GEOSTUDIO_API_KEY)\n    else:\n        raise GeoFMException(\"Missing APIToken. Add `GEOFM_API_TOKEN` to env variables.\")\n\n    # else:\n    #     self.session = session or gfm_session(\n    #         client_id=self.api_config.ISV_CLIENT_ID,\n    #         client_secret=self.api_config.ISV_CLIENT_SECRET,\n    #         well_known_url=self.api_config.ISV_WELL_KNOWN,\n    #         userinfo_endpoint=self.api_config.ISV_USER_ENDPOINT,\n    #     )\n    self.logger = logging.getLogger()\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.create_model","title":"create_model","text":"<pre><code>create_model(data: ModelCreateInput, output: str = 'json')\n</code></pre> <p>Creates a new model using the provided data.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>ModelCreateInput`</code> <p>The input data required to create a new model.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response containing the created model Metadata.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def create_model(self, data: ModelCreateInput, output: str = \"json\"):\n    \"\"\"\n    Creates a new model using the provided data.\n\n    Args:\n        data (ModelCreateInput`): The input data required to create a new model.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The response containing the created model Metadata.\n    \"\"\"\n    payload = json.loads(ModelCreateInput(**data).model_dump_json())\n    response = self.http_post(f\"{self.api_version}/models\", data=payload, output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.list_models","title":"list_models","text":"<pre><code>list_models(output: str = 'json')\n</code></pre> <p>Lists all available models.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the list of models.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def list_models(self, output: str = \"json\"):\n    \"\"\"\n    Lists all available models.\n\n    Args:\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing the list of models.\n    \"\"\"\n    response = self.http_get(\n        endpoint=f\"{self.api_version}/models?limit=1000&amp;skip=0\", output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.update_model","title":"update_model","text":"<pre><code>update_model(model_id: UUID, data: ModelUpdateInput, output: str = 'json')\n</code></pre> <p>Updates metadata of a specified model.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>UUID</code> <p>The unique identifier of the model to be updated.</p> required <code>data</code> <code>dict</code> <p>A dictionary containing the new metadata for the model.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server containing the updated metadata.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def update_model(self, model_id: UUID, data: ModelUpdateInput, output: str = \"json\"):\n    \"\"\"\n    Updates metadata of a specified model.\n\n    Args:\n        model_id (UUID): The unique identifier of the model to be updated.\n        data (dict): A dictionary containing the new metadata for the model.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: The response from the server containing the updated metadata.\n    \"\"\"\n    payload = json.loads(ModelUpdateInput(**data).model_dump_json())\n    response = self.http_patch(\n        f\"{self.api_version}/models/{model_id}\", data=payload, output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.deploy_model","title":"deploy_model","text":"<pre><code>deploy_model(model_id: str, data: ModelOnboardingInputSchema, output='json')\n</code></pre> <p>Deploys a model</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>The unique identifier of the model to be deployed</p> required <code>data</code> <code>ModelOnboardingInputSchema</code> <p>Urls to the model checkpoint and configs</p> required Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def deploy_model(self, model_id: str, data: ModelOnboardingInputSchema, output=\"json\"):\n    \"\"\"\n    Deploys a model\n\n    Args:\n        model_id (str): The unique identifier of the model to be deployed\n        data (ModelOnboardingInputSchema): Urls to the model checkpoint and configs\n\n    \"\"\"\n    payload = json.loads(ModelOnboardingInputSchema(**data).model_dump_json())\n    response = self.http_post(\n        f\"{self.api_version}/models/{model_id}/deploy\", data=payload, output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.get_model","title":"get_model","text":"<pre><code>get_model(model_id: UUID, output: str = 'json')\n</code></pre> <p>Retrieves a model's information using its ID.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>UUID</code> <p>The unique identifier of the model to retrieve.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The model's status and information</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def get_model(self, model_id: UUID, output: str = \"json\"):\n    \"\"\"\n    Retrieves a model's information using its ID.\n\n    Parameters:\n        model_id (UUID): The unique identifier of the model to retrieve.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The model's status and information\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/models/{model_id}\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.delete_model","title":"delete_model","text":"<pre><code>delete_model(model_id: str, output: str = 'json')\n</code></pre> <p>Deletes a specified model using its ID.</p> <p>Parameters:</p> Name Type Description Default <code>model_id</code> <code>str</code> <p>The ID of the model to be deleted.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server after deleting the model.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def delete_model(self, model_id: str, output: str = \"json\"):\n    \"\"\"\n    Deletes a specified model using its ID.\n\n    Args:\n        model_id (str): The ID of the model to be deleted.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: The response from the server after deleting the model.\n    \"\"\"\n    response = self.http_delete(f\"{self.api_version}/models/{model_id}\", output=output)\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.submit_inference","title":"submit_inference","text":"<pre><code>submit_inference(data: InferenceCreateInput, output: str = 'json')\n</code></pre> <p>Submits an inference task to the server.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>InferenceCreateInput</code> <p>The input data for the inference task.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The server's response containing the results of the inference task.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def submit_inference(self, data: InferenceCreateInput, output: str = \"json\"):\n    \"\"\"\n    Submits an inference task to the server.\n\n    Args:\n        data (InferenceCreateInput): The input data for the inference task.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The server's response containing the results of the inference task.\n    \"\"\"\n    payload = json.loads(InferenceCreateInput(**data).model_dump_json())\n    response = self.http_post(f\"{self.api_version}/inference\", data=payload, output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.list_inferences","title":"list_inferences","text":"<pre><code>list_inferences(output: str = 'json')\n</code></pre> <p>Lists inferences submitted to the Studio. Limit to most recent 10.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing a list of inference tasks submitted to the studio</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def list_inferences(self, output: str = \"json\"):\n    \"\"\"\n    Lists inferences submitted to the Studio. Limit to most recent 10.\n\n    Args:\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing a list of inference tasks submitted to the studio\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/inference?limit=10&amp;skip=0\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.get_inference","title":"get_inference","text":"<pre><code>get_inference(inference_id: UUID, output: str = 'json')\n</code></pre> <p>Retrieves the inference with the given inference ID.</p> <p>Parameters:</p> Name Type Description Default <code>inference_id</code> <code>UUID</code> <p>The unique identifier of the inference task.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The inference task data in the specified output format.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def get_inference(self, inference_id: UUID, output: str = \"json\"):\n    \"\"\"\n    Retrieves the inference with the given inference ID.\n\n    Args:\n        inference_id (uuid.UUID): The unique identifier of the inference task.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The inference task data in the specified output format.\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/inference/{inference_id}\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.delete_inference","title":"delete_inference","text":"<pre><code>delete_inference(inference_id: UUID, output: str = 'json')\n</code></pre> <p>Deletes an inference using its ID.</p> <p>Parameters:</p> Name Type Description Default <code>inference_id</code> <code>UUID</code> <p>The ID of the inference to be deleted.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server after deleting the inference.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def delete_inference(self, inference_id: UUID, output: str = \"json\"):\n    \"\"\"\n    Deletes an inference using its ID.\n\n    Args:\n        inference_id (uuid.UUID): The ID of the inference to be deleted.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: The response from the server after deleting the inference.\n    \"\"\"\n    response = self.http_delete(f\"{self.api_version}/inference/{inference_id}\", output=output)\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.get_inference_tasks","title":"get_inference_tasks","text":"<pre><code>get_inference_tasks(inference_id: UUID, output: str = 'json')\n</code></pre> <p>Retrieves the tasks associated with an inference.</p> <p>Parameters:</p> Name Type Description Default <code>inference_id</code> <code>UUID</code> <p>The unique identifier of the inference.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The inference task data in the specified output format.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def get_inference_tasks(self, inference_id: UUID, output: str = \"json\"):\n    \"\"\"\n    Retrieves the tasks associated with an inference.\n\n    Args:\n        inference_id (uuid.UUID): The unique identifier of the inference.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The inference task data in the specified output format.\n    \"\"\"\n    response = self.http_get(\n        f\"{self.api_version}/inference/{inference_id}/tasks\", output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.get_task_output_url","title":"get_task_output_url","text":"<pre><code>get_task_output_url(task_id: UUID, output: str = 'json')\n</code></pre> <p>Retrieves the output url for a specific inference task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>UUID</code> <p>The unique identifier of the task.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The inference task data in the specified output format.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def get_task_output_url(self, task_id: UUID, output: str = \"json\"):\n    \"\"\"\n    Retrieves the output url for a specific inference task.\n\n    Args:\n        task_id (UUID): The unique identifier of the task.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The inference task data in the specified output format.\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/tasks/{task_id}/output\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.get_task_step_logs","title":"get_task_step_logs","text":"<pre><code>get_task_step_logs(task_id: UUID, step_id: str, output: str = 'json')\n</code></pre> <p>Retrieves the logs for a specific step of an inference task.</p> <p>Parameters:</p> Name Type Description Default <code>task_id</code> <code>UUID</code> <p>The unique identifier of the task.</p> required <code>output</code> <code>str</code> <p>The desired output format. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The inference task data in the specified output format.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def get_task_step_logs(self, task_id: UUID, step_id: str, output: str = \"json\"):\n    \"\"\"\n    Retrieves the logs for a specific step of an inference task.\n\n    Args:\n        task_id (UUID): The unique identifier of the task.\n        output (str, optional): The desired output format. Defaults to \"json\".\n\n    Returns:\n        dict: The inference task data in the specified output format.\n    \"\"\"\n    response = self.http_get(\n        f\"{self.api_version}/tasks/{task_id}/logs/{step_id}\", output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.check_data_availability","title":"check_data_availability","text":"<pre><code>check_data_availability(datasource: str, data: DataAdvisorIn, output: str = 'json')\n</code></pre> <p>Query data-advisor service to check data availability before running an inference.</p> <p>Parameters:</p> Name Type Description Default <code>data</code> <code>dict</code> <p>A dictionary containing the necessary parameters for the data availability check.</p> required <code>output</code> <code>str</code> <p>The desired output format. Default is \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server containing the data availability information.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def check_data_availability(self, datasource: str, data: DataAdvisorIn, output: str = \"json\"):\n    \"\"\"\n    Query data-advisor service to check data availability before running an inference.\n\n    Args:\n        data (dict): A dictionary containing the necessary parameters for the data availability check.\n        output (str, optional): The desired output format. Default is \"json\".\n\n    Returns:\n        dict: The response from the server containing the data availability information.\n    \"\"\"\n    payload = json.loads(DataAdvisorIn(**data).model_dump_json())\n    response = self.http_post(\n        f\"{self.api_version}/data-advice/{datasource}\", data=payload, output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.list_datasource_collections","title":"list_datasource_collections","text":"<pre><code>list_datasource_collections(datasource: str, output: str = 'json')\n</code></pre> <p>Query data-advisor to list collections available for a specific data source</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def list_datasource_collections(self, datasource: str, output: str = \"json\"):\n    \"\"\"\n    Query data-advisor to list collections available for a specific data source\n    \"\"\"\n    response = self.http_get(f\"{self.api_version}/data-advice/{datasource}\", output=output, data_field=\"results\")\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.list_datasource","title":"list_datasource","text":"<pre><code>list_datasource(connector: str = None, collection: str = None, limit: int = 25, skip: int = 0, output: str = 'json')\n</code></pre> <p>Lists all data sources available in the studio.</p> <p>Parameters:</p> Name Type Description Default <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing a list of data sources available through the studio</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def list_datasource(\n    self, connector: str = None, collection: str = None, limit: int = 25, skip: int = 0, output: str = \"json\"\n):\n    \"\"\"\n    Lists all data sources available in the studio.\n\n    Args:\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: A dictionary containing a list of data sources available through the studio\n    \"\"\"\n    url = [f\"limit={limit}\", f\"skip={skip}\"]\n\n    if connector:\n        url.append(f\"connector={connector}\")\n    if collection:\n        url.append(f\"collection={collection}\")\n    response = self.http_get(\n        f\"{self.api_version}/data-sources?{'&amp;'.join(url)}\", output=output, data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.get_datasource","title":"get_datasource","text":"<pre><code>get_datasource(datasource_id: UUID, output: str = 'json')\n</code></pre> <p>Retrieves a specific data source's information.</p> <p>Parameters:</p> Name Type Description Default <code>datasource_id</code> <code>UUID</code> <p>The unique identifier of the data source to retrieve.</p> required <code>output</code> <code>str</code> <p>The format of the response. Defaults to \"json\".</p> <code>'json'</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the server containing the data source details.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def get_datasource(self, datasource_id: UUID, output: str = \"json\"):\n    \"\"\"\n    Retrieves a specific data source's information.\n\n    Args:\n        datasource_id (UUID): The unique identifier of the data source to retrieve.\n        output (str, optional): The format of the response. Defaults to \"json\".\n\n    Returns:\n        dict: The response from the server containing the data source details.\n    \"\"\"\n    results = self.list_datasource()[\"results\"]\n    data_source = list(filter(lambda x: x[\"id\"] == datasource_id, results))\n    return data_source\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.get_fileshare_links","title":"get_fileshare_links","text":"<pre><code>get_fileshare_links(object_name: str)\n</code></pre> <p>Generate presigned urls for sharing files i.e uploading and downloading files.</p> <p>Parameters:</p> Name Type Description Default <code>object_name</code> <code>str</code> <p>The name of the object (file) for which to generate upload links.</p> required <p>Returns:</p> Name Type Description <code>dict</code> <p>A dictionary containing the upload links.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def get_fileshare_links(self, object_name: str):\n    \"\"\"\n    Generate presigned urls for sharing files i.e uploading and downloading files.\n\n    Args:\n        object_name (str): The name of the object (file) for which to generate upload links.\n\n    Returns:\n        dict: A dictionary containing the upload links.\n    \"\"\"\n    print(\"Going to generate the upload link\")\n    response = self.http_get(\n        f\"{self.api_version}/file-share?object_name={object_name}\", output=\"json\", data_field=\"results\"\n    )\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.upload_file_to_url","title":"upload_file_to_url","text":"<pre><code>upload_file_to_url(upload_url: str, filepath: str)\n</code></pre> <p>Uploads a file to a specified URL using a PUT request.</p> <p>Parameters:</p> Name Type Description Default <code>upload_url</code> <code>str</code> <p>The URL to which the file will be uploaded.</p> required <code>filepath</code> <code>str</code> <p>The path to the file that will be uploaded.</p> required <p>Returns:</p> Type Description <p>requests.Response: The response from the server after the file upload.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def upload_file_to_url(self, upload_url: str, filepath: str):\n    \"\"\"\n    Uploads a file to a specified URL using a PUT request.\n\n    Args:\n        upload_url (str): The URL to which the file will be uploaded.\n        filepath (str): The path to the file that will be uploaded.\n\n    Returns:\n        requests.Response: The response from the server after the file upload.\n    \"\"\"\n\n    print(\"Going to upload the file to the url.\")\n\n    fields = {}\n    path = Path(filepath)\n    total_size = path.stat().st_size\n    filename = path.name\n\n    with Progress(\n        TextColumn(\"[bold black]{task.description}\"),\n        BarColumn(),\n        DownloadColumn(),\n        TransferSpeedColumn(),\n        TimeRemainingColumn(),\n    ) as progress_bar:\n        task = progress_bar.add_task(filename, total=total_size)\n        with open(filepath, \"rb\") as f:\n            fields[\"file\"] = (\"filename\", f)\n            e = MultipartEncoder(fields=fields)\n            last_bytes = 0\n\n            def monitor_callback(monitor):\n                nonlocal last_bytes\n                bytes_diff = monitor.bytes_read - last_bytes\n                progress_bar.update(task, advance=bytes_diff)\n                last_bytes = monitor.bytes_read\n\n            m = MultipartEncoderMonitor(e, monitor_callback)\n\n            headers = {\"Content-Type\": m.content_type}\n            response = requests.put(upload_url, data=m, headers=headers)\n    return response\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.upload_file","title":"upload_file","text":"<pre><code>upload_file(filename: str)\n</code></pre> <p>Streamlines :py:meth:<code>get_upload_links</code> and :py:meth:<code>upload_file_to_url</code>. Uploads a file to a specified location using the provided upload links.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def upload_file(self, filename: str):\n    \"\"\"\n    Streamlines :py:meth:`get_upload_links` and :py:meth:`upload_file_to_url`.\n    Uploads a file to a specified location using the provided upload links.\n    \"\"\"\n    links = self.get_fileshare_links(object_name=filename.split(\"/\")[-1])\n    # print(links)\n    upload_url = links.get(\"upload_url\", None)\n    if upload_url:\n        self.upload_file_to_url(links[\"upload_url\"], filename)\n    return links\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.create_download_presigned_url","title":"create_download_presigned_url","text":"<pre><code>create_download_presigned_url(bucket_name: str, object_key: str, endpoint_url: str, region_name: str, service_name: str, aws_access_key_id: str = None, aws_secret_access_key: str = None, expiration: int = 3600, **kwargs)\n</code></pre> <p>Function to create presigned url to download object from bucket</p>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.create_download_presigned_url--parameters","title":"Parameters","text":"<p>bucket_name : str     The bucket name in the instance object_key : str     Object path to pre-sign endpoint_url: str     s3 Endpoint i.e https://s3.us-east.cloud-object-storage.appdomain.cloud region_name: str     Region where bucket lives. i.e us-east service_name: str     service to connect to i.e s3 aws_access_key_id: str     AWS Access key to the instance aws_secret_access_key: str     AWS secret access key to the instance expiration : int, optional     Expiration duration in seconds, by default 3600</p>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.create_download_presigned_url--returns","title":"Returns","text":"<p>str     Presigned download url</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def create_download_presigned_url(\n    self,\n    bucket_name: str,\n    object_key: str,\n    endpoint_url: str,\n    region_name: str,\n    service_name: str,\n    aws_access_key_id: str = None,\n    aws_secret_access_key: str = None,\n    expiration: int = 3600,\n    **kwargs,\n):\n    \"\"\"Function to create presigned url to download object from bucket\n\n    Parameters\n    ----------\n    bucket_name : str\n        The bucket name in the instance\n    object_key : str\n        Object path to pre-sign\n    endpoint_url: str\n        s3 Endpoint i.e https://s3.us-east.cloud-object-storage.appdomain.cloud\n    region_name: str\n        Region where bucket lives. i.e us-east\n    service_name: str\n        service to connect to i.e s3\n    aws_access_key_id: str\n        AWS Access key to the instance\n    aws_secret_access_key: str\n        AWS secret access key to the instance\n    expiration : int, optional\n        Expiration duration in seconds, by default 3600\n\n    Returns\n    -------\n    str\n        Presigned download url\n    \"\"\"\n\n    s3_client = boto3.client(\n        service_name,\n        region_name=region_name,\n        endpoint_url=endpoint_url,\n        aws_secret_access_key=aws_secret_access_key,\n        aws_access_key_id=aws_access_key_id,\n        **kwargs,\n    )\n    try:\n        download_url = s3_client.generate_presigned_url(\n            ClientMethod=\"get_object\",\n            Params={\"Bucket\": bucket_name, \"Key\": object_key},\n            ExpiresIn=expiration,\n        )\n    except ClientError as e:\n        print(f\"Error creating presigned URL: {e}\")\n        return None\n\n    return download_url\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.create_upload_presigned_url","title":"create_upload_presigned_url","text":"<pre><code>create_upload_presigned_url(bucket_name: str, object_key: str, endpoint_url: str, region_name: str, service_name: str, aws_access_key_id: str = None, aws_secret_access_key: str = None, expiration: int = 3600, **kwargs)\n</code></pre> <p>Function to create presigned url to upload object from bucket</p>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.create_upload_presigned_url--parameters","title":"Parameters","text":"<p>bucket_name : str     The bucket name in the instance object_key : str     Object path to pre-sign endpoint_url: str     s3 Endpoint i.e https://s3.us-east.cloud-object-storage.appdomain.cloud region_name: str     Region where bucket lives. i.e us-east service_name: str     service to connect to i.e s3 aws_access_key_id: str     AWS Access key to the instance aws_secret_access_key: str     AWS secret access key to the instance expiration : int, optional     Expiration duration in seconds, by default 3600</p>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.create_upload_presigned_url--returns","title":"Returns","text":"<p>str     Presigned upload url</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def create_upload_presigned_url(\n    self,\n    bucket_name: str,\n    object_key: str,\n    endpoint_url: str,\n    region_name: str,\n    service_name: str,\n    aws_access_key_id: str = None,\n    aws_secret_access_key: str = None,\n    expiration: int = 3600,\n    **kwargs,\n):\n    \"\"\"Function to create presigned url to upload object from bucket\n\n    Parameters\n    ----------\n    bucket_name : str\n        The bucket name in the instance\n    object_key : str\n        Object path to pre-sign\n    endpoint_url: str\n        s3 Endpoint i.e https://s3.us-east.cloud-object-storage.appdomain.cloud\n    region_name: str\n        Region where bucket lives. i.e us-east\n    service_name: str\n        service to connect to i.e s3\n    aws_access_key_id: str\n        AWS Access key to the instance\n    aws_secret_access_key: str\n        AWS secret access key to the instance\n    expiration : int, optional\n        Expiration duration in seconds, by default 3600\n\n    Returns\n    -------\n    str\n        Presigned upload url\n    \"\"\"\n\n    s3_client = boto3.client(\n        service_name,\n        region_name=region_name,\n        endpoint_url=endpoint_url,\n        aws_secret_access_key=aws_secret_access_key,\n        aws_access_key_id=aws_access_key_id,\n        **kwargs,\n    )\n    try:\n        upload_url = s3_client.generate_presigned_url(\n            ClientMethod=\"put_object\",\n            Params={\"Bucket\": bucket_name, \"Key\": object_key},\n            ExpiresIn=expiration,\n        )\n    except ClientError as e:\n        print(f\"Error creating presigned URL: {e}\")\n        return None\n\n    return upload_url\n</code></pre>"},{"location":"inference/#geostudio.backends.v2.ginference.client.Client.poll_inference_until_finished","title":"poll_inference_until_finished","text":"<pre><code>poll_inference_until_finished(inference_id, poll_frequency=10)\n</code></pre> <p>Polls the status of an inference task until it is completed or failed. Defaults to a minimum of 5seconds poll frequency.</p> <p>Parameters:</p> Name Type Description Default <code>inference_id</code> <code>str</code> <p>The unique identifier of the inference task.</p> required <code>poll_frequency</code> <code>int</code> <p>The time interval in seconds between polls. Defaults to 5 seconds.</p> <code>10</code> <p>Returns:</p> Name Type Description <code>dict</code> <p>The response from the inference task when it is completed or failed.</p> Source code in <code>geostudio/backends/v2/ginference/client.py</code> <pre><code>def poll_inference_until_finished(self, inference_id, poll_frequency=10):\n    \"\"\"\n    Polls the status of an inference task until it is completed or failed.\n    Defaults to a minimum of 5seconds poll frequency.\n\n    Args:\n        inference_id (str): The unique identifier of the inference task.\n        poll_frequency (int, optional): The time interval in seconds between polls. Defaults to 5 seconds.\n\n    Returns:\n        dict: The response from the inference task when it is completed or failed.\n    \"\"\"\n    poll_frequency = 10 if poll_frequency &lt; 10 else poll_frequency\n    finished = False\n\n    while finished is False:\n        r = self.get_inference(inference_id)\n        status = r[\"status\"]\n        time_taken = (\n            datetime.now(timezone.utc)\n            - datetime.strptime(r[\"created_at\"], \"%Y-%m-%dT%H:%M:%S.%fZ\").replace(tzinfo=timezone.utc)\n        ).seconds\n\n        if \"COMPLETED\" in status:\n            print(status + \" - \" + str(time_taken) + \" seconds\")\n            finished = True\n            return r\n\n        elif status == \"FAILED\":\n            print(status + \" - \" + str(time_taken) + \" seconds\")\n            finished = True\n            return r\n\n        elif status == \"STOPPED\":\n            print(status + \" - \" + str(time_taken) + \" seconds\")\n            finished = True\n            return r\n\n        else:\n            print(status + \" - \" + str(time_taken) + \" seconds\", end=\"\\r\")\n\n        sleep(poll_frequency)\n</code></pre>"},{"location":"models/","title":"Models","text":""},{"location":"models/#geostudio.backends.v2.ginference.models","title":"geostudio.backends.v2.ginference.models","text":""},{"location":"models/#geostudio.backends.v2.ginference.models.ModelOnboardingInputSchema","title":"ModelOnboardingInputSchema","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Inference client Client deploy_model </li> </ul>"},{"location":"models/#geostudio.backends.v2.ginference.models.ModelUpdateInput","title":"ModelUpdateInput","text":"<p>               Bases: <code>BaseModel</code></p> Subclassed by: <ul> <li> Models Models models ModelCreateInput </li> </ul> Used by: <ul> <li> SDK Client Inference client Client update_model </li> </ul>"},{"location":"models/#geostudio.backends.v2.ginference.models.ModelCreateInput","title":"ModelCreateInput","text":"<p>               Bases: <code>ModelUpdateInput</code></p> Used by: <ul> <li> SDK Client Inference client Client create_model </li> </ul>"},{"location":"models/#geostudio.backends.v2.ginference.models.SpatialDomain","title":"SpatialDomain","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"models/#geostudio.backends.v2.ginference.models.DataSource","title":"DataSource","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"models/#geostudio.backends.v2.ginference.models.GeoServerPush","title":"GeoServerPush","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"models/#geostudio.backends.v2.ginference.models.PostProcessing","title":"PostProcessing","text":"<p>               Bases: <code>BaseModel</code></p>"},{"location":"models/#geostudio.backends.v2.ginference.models.InferenceConfig","title":"InferenceConfig","text":"<p>               Bases: <code>BaseModel</code></p> Subclassed by: <ul> <li> Models Models models InferenceCreateInput </li> </ul>"},{"location":"models/#geostudio.backends.v2.ginference.models.InferenceCreateInput","title":"InferenceCreateInput","text":"<p>               Bases: <code>InferenceConfig</code></p> Used by: <ul> <li> SDK Client Inference client Client submit_inference </li> </ul>"},{"location":"models/#geostudio.backends.v2.ginference.models.DataAdvisorIn","title":"DataAdvisorIn","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Inference client Client check_data_availability </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models","title":"geostudio.backends.v2.gtune.models","text":""},{"location":"models/#geostudio.backends.v2.gtune.models.TuneUpdateIn","title":"TuneUpdateIn","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client update_tune </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.TuneSubmitBase","title":"TuneSubmitBase","text":"<p>               Bases: <code>BaseModel</code></p> Subclassed by: <ul> <li> Models Models models TuneSubmitIn </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.TuneSubmitBase.validate_name","title":"validate_name  <code>classmethod</code>","text":"<pre><code>validate_name(name: str) -&gt; str\n</code></pre> <p>Validates the tune name</p>"},{"location":"models/#geostudio.backends.v2.gtune.models.TuneSubmitBase.validate_name--parameters","title":"Parameters","text":"<p>name : str     The name of the tune.</p>"},{"location":"models/#geostudio.backends.v2.gtune.models.TuneSubmitBase.validate_name--returns","title":"Returns","text":"<p>str     Cleaned up name of the tune without special characters or white spaces.</p>"},{"location":"models/#geostudio.backends.v2.gtune.models.TuneSubmitBase.validate_name--raises","title":"Raises","text":"<p>ValueError      If <code>name</code> contains special characters or white spaces.</p> Source code in <code>geostudio/backends/v2/gtune/models.py</code> <pre><code>@field_validator(\"name\")\n@classmethod\ndef validate_name(cls, name: str) -&gt; str:\n    \"\"\"Validates the tune name\n\n    Parameters\n    ----------\n    name : str\n        The name of the tune.\n\n    Returns\n    -------\n    str\n        Cleaned up name of the tune without special characters or white spaces.\n\n    Raises\n    ------\n    ValueError\n         If `name` contains special characters or white spaces.\n    \"\"\"\n    # Clean-up the tune name.\n    name = name.replace(\" \", \"-\").replace(\"_\", \"-\").strip()\n    if not re.match(\"^[a-zA-Z0-9]+([.-]{0,1}[a-zA-Z0-9]+)*$\", name):\n        raise ValueError(\"must not contain special characters or white spaces. Replace underscores with hyphens.\")\n    return name\n</code></pre>"},{"location":"models/#geostudio.backends.v2.gtune.models.TuneSubmitIn","title":"TuneSubmitIn","text":"<p>               Bases: <code>TuneSubmitBase</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client submit_tune </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.HpoTuneSubmitIn","title":"HpoTuneSubmitIn","text":"<p>               Bases: <code>BaseModel</code></p> <p>Schema for hpo tune submission.</p> Used by: <ul> <li> SDK Client Fine-tuning client Client submit_hpo_tune </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.TryOutTuneInput","title":"TryOutTuneInput","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client try_out_tune </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.UploadTuneInput","title":"UploadTuneInput","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client upload_completed_tunes </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.TaskPurposeEnum","title":"TaskPurposeEnum","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"models/#geostudio.backends.v2.gtune.models.TaskIn","title":"TaskIn","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client create_task </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.PreScanDatasetIn","title":"PreScanDatasetIn","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client pre_scan_dataset </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.DatasetUpdateIn","title":"DatasetUpdateIn","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client update_dataset </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.GeoDatasetTrainParamUpdateSchema","title":"GeoDatasetTrainParamUpdateSchema","text":"<p>               Bases: <code>BaseModel</code></p> Subclassed by: <ul> <li> Models Models models DatasetOnboardIn </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.DatasetOnboardIn","title":"DatasetOnboardIn","text":"<p>               Bases: <code>GeoDatasetTrainParamUpdateSchema</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client onboard_dataset </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.ModelCategory","title":"ModelCategory","text":"<p>               Bases: <code>str</code>, <code>Enum</code></p>"},{"location":"models/#geostudio.backends.v2.gtune.models.BaseModelParamsIn","title":"BaseModelParamsIn","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client update_base_model_params </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.BaseModelsIn","title":"BaseModelsIn","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client create_base_model </li> </ul>"},{"location":"models/#geostudio.backends.v2.gtune.models.BaseModelParamsIn","title":"BaseModelParamsIn","text":"<p>               Bases: <code>BaseModel</code></p> Used by: <ul> <li> SDK Client Fine-tuning client Client update_base_model_params </li> </ul>"},{"location":"widgets/","title":"Widgets","text":""},{"location":"widgets/#geostudio.gswidgets","title":"geostudio.gswidgets","text":""},{"location":"widgets/#geostudio.gswidgets.geojson_to_details","title":"geojson_to_details","text":"<pre><code>geojson_to_details(geojson)\n</code></pre> <p>This function takes a GeoJSON object as input and returns a string containing the area, perimeter, and bounding box coordinates of the polygon.</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>A dictionary representing a GeoJSON object with 'geometry' and 'type' keys.          The 'geometry' key should contain a dictionary with 'type' set to 'Polygon' and 'coordinates' containing a list of coordinate pairs.          The 'type' key should be set to 'Feature'.</p> required <p>Returns:</p> Name Type Description <code>str</code> <p>A string containing the area (in square kilometers), perimeter (in kilometers), and bounding box coordinates (in decimal degrees) of the polygon.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def geojson_to_details(geojson):\n    \"\"\"\n    This function takes a GeoJSON object as input and returns a string containing the area, perimeter, and bounding box coordinates of the polygon.\n\n    Args:\n        geojson (dict): A dictionary representing a GeoJSON object with 'geometry' and 'type' keys.\n                     The 'geometry' key should contain a dictionary with 'type' set to 'Polygon' and 'coordinates' containing a list of coordinate pairs.\n                     The 'type' key should be set to 'Feature'.\n\n    Returns:\n        str: A string containing the area (in square kilometers), perimeter (in kilometers), and bounding box coordinates (in decimal degrees) of the polygon.\n    \"\"\"\n\n    print(geojson.get(\"geometry\"))\n    # gdf4326 = gpd.GeoDataFrame(index=[0], crs='epsg:4326', geometry=[geojson.get('geometry')])\n    gdf4326 = gpd.GeoDataFrame.from_features([geojson], crs=\"epsg:4326\")\n\n    # Get the geometry from `gdf4326`\n    pgon = gdf4326.geometry.iloc[0]\n    # Extract list of longitude/latitude of polygon's boundary\n    lons, lats = pgon.exterior.xy[:][0], pgon.exterior.xy[:][1]\n\n    geod = Geod(\"+a=6378137 +f=0.0033528106647475126\")\n    poly_area, poly_perimeter = geod.polygon_area_perimeter(lons, lats)\n\n    bbox_list = [round(pgon.bounds[0], 5), round(pgon.bounds[1], 5), round(pgon.bounds[2], 5), round(pgon.bounds[3], 5)]\n\n    if bbox_list[0] &gt; 180:\n        bbox_list[0] = round(bbox_list[0] - 360, 5)\n    if bbox_list[2] &gt; 180:\n        bbox_list[2] = round(bbox_list[2] - 360, 5)\n\n    # Print the results\n    output_details = \"Area, (sq.km): {:.1f}\".format(abs(poly_area) / 1000000) + \"\\n\"\n    output_details = output_details + \"Perimeter, (km): {:.2f}\".format(poly_perimeter / 1000) + \"\\n\"\n    output_details = output_details + \"Bounding box coordinates: {}\".format(str(bbox_list))\n\n    return output_details\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.geojson_to_bbox","title":"geojson_to_bbox","text":"<pre><code>geojson_to_bbox(geojson)\n</code></pre> <p>Convert a GeoJSON feature to a bounding box in the format [west, south, east, north].</p> <p>Parameters:</p> Name Type Description Default <code>geojson</code> <code>dict</code> <p>A dictionary representing a GeoJSON feature. It should contain a 'geometry' key with a GeoJSON geometry object.</p> required <p>Returns:</p> Name Type Description <code>list</code> <p>A list of four floating point numbers representing the bounding box in the order [west, south, east, north].</p> <p>The values are rounded to 5 decimal places. Longitude and latitude values are adjusted to be within the range [-180, 180].</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def geojson_to_bbox(geojson):\n    \"\"\"\n    Convert a GeoJSON feature to a bounding box in the format [west, south, east, north].\n\n    Args:\n        geojson (dict): A dictionary representing a GeoJSON feature. It should contain a 'geometry' key with a GeoJSON geometry object.\n\n    Returns:\n        list: A list of four floating point numbers representing the bounding box in the order [west, south, east, north].\n        The values are rounded to 5 decimal places. Longitude and latitude values are adjusted to be within the range [-180, 180].\n    \"\"\"\n\n    gdf4326 = gpd.GeoDataFrame.from_features([geojson], crs=\"epsg:4326\")\n\n    # Get the geometry from `gdf4326`\n    pgon = gdf4326.geometry.iloc[0]\n    bbox_list = [round(pgon.bounds[0], 5), round(pgon.bounds[1], 5), round(pgon.bounds[2], 5), round(pgon.bounds[3], 5)]\n\n    if bbox_list[0] &gt; 180:\n        bbox_list[0] = bbox_list[0] - 360\n    if bbox_list[2] &gt; 180:\n        bbox_list[2] = bbox_list[2] - 360\n\n    return bbox_list\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.list_output_files","title":"list_output_files","text":"<pre><code>list_output_files(url, just_tif=True)\n</code></pre> <p>Lists the files present in a remote zip archive.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the remote zip archive.</p> required <code>just_tif</code> <code>bool</code> <p>If True, only return files with '.tif' extension. Defaults to True.</p> <code>True</code> <p>Returns:</p> Type Description <p>List[str]: A list of filenames present in the zip archive.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def list_output_files(url, just_tif=True):\n    \"\"\"\n    Lists the files present in a remote zip archive.\n\n    Args:\n        url (str): The URL of the remote zip archive.\n        just_tif (bool, optional): If True, only return files with '.tif' extension. Defaults to True.\n\n    Returns:\n        List[str]: A list of filenames present in the zip archive.\n    \"\"\"\n    with RemoteZip(url) as zip:\n        il = zip.infolist()\n    if just_tif == True:\n        return [X.filename for X in il if X.filename[-4:] == \".tif\"]\n    else:\n        return [X.filename for X in il]\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.download_file","title":"download_file","text":"<pre><code>download_file(url, filename, output_path='./')\n</code></pre> <p>Downloads a file from a given URL and saves it to a specified output path.</p> <p>Parameters:</p> Name Type Description Default <code>url</code> <code>str</code> <p>The URL of the file to download.</p> required <code>filename</code> <code>str</code> <p>The name of the file to save locally.</p> required <code>output_path</code> <code>str</code> <p>The directory where the file will be saved. Defaults to './'.</p> <code>'./'</code> <p>Returns:</p> Name Type Description <code>str</code> <p>The path where the file was saved.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def download_file(url, filename, output_path=\"./\"):\n    \"\"\"\n    Downloads a file from a given URL and saves it to a specified output path.\n\n    Args:\n        url (str): The URL of the file to download.\n        filename (str): The name of the file to save locally.\n        output_path (str, optional): The directory where the file will be saved. Defaults to './'.\n\n    Returns:\n        str: The path where the file was saved.\n    \"\"\"\n    with RemoteZip(url) as zip:\n        a = zip.extract(filename, path=output_path)\n    return a\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.bboxSelector","title":"bboxSelector","text":"<pre><code>bboxSelector()\n</code></pre> <p>Creates a user interface for selecting a bounding box on a map.</p> <p>Returns:</p> Type Description <p>ipywidgets.widgets.GridspecLayout: A grid layout containing that can be displayed in a Jupyter notebook or similar environment. It contains a map, a search control, a full screen control, a title, a text area for displaying bounding box details,</p> <p>a clear button, and a use button. The map has a draw control for selecting a bounding box.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def bboxSelector():\n    \"\"\"\n    Creates a user interface for selecting a bounding box on a map.\n\n    Args:\n        None\n\n    Returns:\n        ipywidgets.widgets.GridspecLayout: A grid layout containing that can be displayed in a Jupyter notebook or similar environment. It contains a map, a search control, a full screen control, a title, a text area for displaying bounding box details,\n        a clear button, and a use button. The map has a draw control for selecting a bounding box.\n    \"\"\"\n    bbox = []\n\n    grid = widgets.GridspecLayout(4, 4, height=\"400px\")\n\n    m = Map(center=(50, 354), zoom=5, scroll_wheel_zoom=True)\n\n    draw_control = DrawControl(polyline={}, circle={}, polygon={}, circlemarker={})\n\n    draw_control.rectangle = {\"shapeOptions\": {\"fillColor\": \"#fca45d\", \"color\": \"#fca45d\", \"fillOpacity\": 0.3}}\n\n    m.add(SearchControl(position=\"topleft\", url=\"https://nominatim.openstreetmap.org/search?format=json&amp;q={s}\", zoom=8))\n\n    m.add(FullScreenControl())\n\n    grid[:, 1:4] = m\n\n    title = widgets.HTML(\n        value=\"&lt;h1&gt;Bounding box selector&lt;/h1&gt; &lt;/p&gt;Use the map on the right to draw a bounding box.  Once you selected it you will see the details of the bounding box below.\"\n    )\n\n    grid[0, 0] = title\n\n    bbox_details = widgets.Textarea(value=\"Your bbox info will appear here\", description=\"\", disabled=False, rows=5)\n\n    grid[1, 0] = bbox_details\n\n    def on_bbox_draw(self, action, geo_json):\n        \"\"\"\n        Callback function for the draw control's on_draw event.\n\n        Args:\n            self: The draw control object.\n            action: The action that triggered the event.\n            geo_json: The GeoJSON representation of the drawn shape.\n\n        Returns:\n            None\n        \"\"\"\n        print(geo_json)\n        bbox_details.value = geojson_to_details(geo_json)\n        # bbox_details.value = json.dumps(geo_json)\n\n    draw_control.on_draw(on_bbox_draw)\n\n    m.add(draw_control)\n\n    button_layout1 = widgets.Layout(width=\"auto\", height=\"40px\")  # set width and height\n    button_layout2 = widgets.Layout(width=\"auto\", height=\"40px\")  # set width and height\n\n    clear_button = widgets.Button(\n        description=\"Clear bboxes\",\n        button_style=\"warning\",\n        display=\"flex\",\n        flex_flow=\"column\",\n        align_items=\"stretch\",\n        layout=button_layout1,\n    )\n\n    def on_clear_click(b):\n        \"\"\"\n        Callback function for the clear button's on_click event.\n\n        Args:\n            b: The button object.\n\n        Returns:\n            None\n        \"\"\"\n        draw_control.clear()\n        bbox_details.value = \"Your bbox info will appear here\"\n\n    clear_button.on_click(on_clear_click)\n\n    grid[2, 0] = clear_button\n\n    use_button = widgets.Button(\n        description=\"Use this bounding box\",\n        button_style=\"success\",\n        display=\"flex\",\n        flex_flow=\"column\",\n        align_items=\"stretch\",\n        layout=button_layout2,\n    )\n\n    def on_use_click(b):\n        \"\"\"\n        Callback function for the use button's on_click event.\n\n        Args:\n            b: The button object.\n\n        Returns:\n            The bounding box coordinates as a list.\n        \"\"\"\n        # global bbox\n        bbox = geojson_to_bbox(draw_control.last_draw)\n        draw_control.last_draw[\"properties\"][\"style\"][\"fillColor\"] = \"#32a852\"\n        print(bbox)\n        return bbox\n\n    bbox = use_button.on_click(on_use_click)\n\n    # grid[3,0] = use_button\n\n    return grid\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.time_selector","title":"time_selector","text":"<pre><code>time_selector()\n</code></pre> <p>Creates a time range selector using ipywidgets.</p> <p>Returns:</p> Type Description <p>ipywidgets.widgets.GridspecLayout: A layout containing two datetime pickers for selecting a start and end time.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def time_selector():\n    \"\"\"\n    Creates a time range selector using ipywidgets.\n\n    Args:\n        None\n\n    Returns:\n        ipywidgets.widgets.GridspecLayout: A layout containing two datetime pickers for selecting a start and end time.\n    \"\"\"\n    start_time_picker = widgets.DatetimePicker(description=\"Start time:  \", disabled=False)\n\n    end_time_picker = widgets.DatetimePicker(description=\"End time:  \", disabled=False)\n\n    grid = widgets.GridspecLayout(4, 2, height=\"200px\")\n\n    grid[0, 0:2] = widgets.HTML(\n        value=\"&lt;h1&gt;Time range selector&lt;/h1&gt; &lt;/p&gt;Use the datetime pickers to pick a time window for inference.\"\n    )\n    grid[1, 0] = start_time_picker\n    grid[2, 0] = end_time_picker\n\n    return grid\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.add_geotiff","title":"add_geotiff","text":"<pre><code>add_geotiff(filename, layer_name='', colormap='viridis', cmin=0, cmax='', opacity=1.0)\n</code></pre> <p>Adds a GeoTIFF file to a Folium map as an overlay.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the GeoTIFF file.</p> required <code>layer_name</code> <code>str</code> <p>The name of the layer. Defaults to \"\".</p> <code>''</code> <code>colormap</code> <code>str</code> <p>The colormap to use for the GeoTIFF data. Defaults to \"viridis\".</p> <code>'viridis'</code> <code>cmin</code> <code>int or float</code> <p>The minimum value for the colormap. Defaults to 0.</p> <code>0</code> <code>cmax</code> <code>int or float</code> <p>The maximum value for the colormap. If not provided, it is automatically calculated as the maximum value in the GeoTIFF data. Defaults to \"\".</p> <code>''</code> <code>opacity</code> <code>float</code> <p>The opacity of the overlay. Defaults to 1.0.</p> <code>1.0</code> <p>Returns:</p> Type Description <p>folium.raster_layers.ImageOverlay: An ImageOverlay object that can be added to a Folium map.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def add_geotiff(filename, layer_name=\"\", colormap=\"viridis\", cmin=0, cmax=\"\", opacity=1.0):\n    \"\"\"\n    Adds a GeoTIFF file to a Folium map as an overlay.\n\n    Args:\n        filename (str): The path to the GeoTIFF file.\n        layer_name (str, optional): The name of the layer. Defaults to \"\".\n        colormap (str, optional): The colormap to use for the GeoTIFF data. Defaults to \"viridis\".\n        cmin (int or float, optional): The minimum value for the colormap. Defaults to 0.\n        cmax (int or float, optional): The maximum value for the colormap. If not provided, it is automatically calculated as the maximum value in the GeoTIFF data. Defaults to \"\".\n        opacity (float, optional): The opacity of the overlay. Defaults to 1.0.\n\n    Returns:\n        folium.raster_layers.ImageOverlay: An ImageOverlay object that can be added to a Folium map.\n    \"\"\"\n    with rasterio.open(filename) as src:\n        dataArray = src.read(1)\n        bounds = src.bounds\n        nd = src.nodata\n\n    # TODO remove - never used\n    # midLat = (bounds[3] + bounds[1]) / 2\n    # midLon = (bounds[2] + bounds[0]) / 2\n\n    if cmax == \"\":\n        cmax = np.max(dataArray)\n    dataArrayMasked = np.ma.masked_where(dataArray == nd, dataArray)\n    imc = colorize(dataArrayMasked, cmax, cmin=cmin, cmap=colormap)\n\n    return folium.raster_layers.ImageOverlay(\n        imc,\n        [[bounds[1], bounds[0]], [bounds[3], bounds[2]]],\n        name=layer_name,\n        opacity=opacity,\n    )\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.colorize","title":"colorize","text":"<pre><code>colorize(array, cmax, cmin=0, cmap='rainbow')\n</code></pre> <p>Converts a 2D numpy array of values into an RGBA array given a colour map and range.</p> <p>Parameters:</p> Name Type Description Default <code>array</code> <code>ndarray</code> required <code>cmax</code> <code>float</code> <p>Max value for colour range</p> required <code>cmin</code> <code>float</code> <p>Min value for colour range</p> <code>0</code> <code>cmap</code> <code>string</code> <p>Colour map to use (from matplotlib colourmaps)</p> <code>'rainbow'</code> <p>Returns:</p> Name Type Description <code>rgba_array</code> <code>ndarray</code> <p>3D RGBA array which can be plotted.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def colorize(array, cmax, cmin=0, cmap=\"rainbow\"):\n    \"\"\"Converts a 2D numpy array of values into an RGBA array given a colour map and range.\n\n    Args:\n        array (ndarray):\n        cmax (float): Max value for colour range\n        cmin (float): Min value for colour range\n        cmap (string): Colour map to use (from matplotlib colourmaps)\n\n    Returns:\n            rgba_array (ndarray): 3D RGBA array which can be plotted.\n    \"\"\"\n    normed_data = (array - cmin) / (array.max() - cmin)\n    cm = plt.cm.get_cmap(cmap)\n    return cm(normed_data)\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.available_models_ui","title":"available_models_ui","text":"<pre><code>available_models_ui(client)\n</code></pre> <p>A UI for browsing and selecting available models.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>object</code> <p>:py:class:<code>geostudio.backends.ginference.client.Client</code></p> required <p>Returns:</p> Type Description <p>widgets.VBox: A Jupyter widget containing a header, text input for filtering, checkbox for active models, interactive dropdown for selecting a model, and the model selection table.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def available_models_ui(client):\n    \"\"\"\n    A UI for browsing and selecting available models.\n\n    Args:\n        client (object): :py:class:`geostudio.backends.ginference.client.Client`\n\n    Returns:\n        widgets.VBox: A Jupyter widget containing a header, text input for filtering, checkbox for active models, interactive dropdown for selecting a model, and the model selection table.\n    \"\"\"\n    # workflows = self.available_workflows()\n    models_df = client.list_models(output=\"df\")\n    models_trim = models_df[[\"name\", \"description\", \"created_at\", \"created_by\", \"active\"]].sort_values(by=[\"name\"])\n\n    # all_tags = []\n    # [all_tags.extend(X) for X in wf_trim.tags]\n    # diff_tags = list(np.unique(np.array(all_tags)))\n\n    def view(name=\"\", active=True):\n        \"\"\"\n        Displays a filtered list of models based on the provided name and active status.\n\n        Args:\n            name (str, optional): The name of the model(s) to filter by. If not provided, all models are displayed.\n            active (bool, optional): Whether to filter models by their active status. If True, only active models are displayed.\n\n        Returns:\n            None\n        \"\"\"\n        if name != \"\":\n            models_trim_filtered = models_trim[[name in X for X in models_trim.name]]\n        else:\n            models_trim_filtered = models_trim\n\n        if active == True:\n            models_trim_filtered = models_trim_filtered[models_trim_filtered.active == True]\n            #     [\"true\" in X for X in models_trim_filtered.active]\n            # ]\n        else:\n            models_trim_filtered = models_trim_filtered\n\n        model_names = list(models_trim_filtered.name)\n\n        if len(model_names) &gt; 0:\n            wf_dd.options = model_names\n        else:\n            wf_dd.value = \"None found\"\n            wf_dd.options = [\"None found\"]\n\n        return display(HTML(models_trim_filtered.to_html(index=False)))\n\n    keyText = widgets.Text(\n        value=\"\",\n        placeholder=\"Type something to filter results\",\n        description=\"Model name:\",\n        disabled=False,\n        layout=widgets.Layout(height=\"auto\", width=\"400px\"),\n    )\n\n    wf_dd = widgets.Dropdown(\n        options=list(models_trim.name),\n        value=list(models_trim.name)[0],\n        description=\"Select Model:\",\n        disabled=False,\n        layout=widgets.Layout(height=\"auto\", width=\"600px\"),\n    )\n\n    def on_change(change):\n        if change[\"type\"] == \"change\" and change[\"name\"] == \"value\":\n            model_name = change[\"new\"]\n\n    wf_dd.observe(on_change)\n\n    activeCheck = widgets.Checkbox(value=True, description=\"Active only?\", disabled=False)\n\n    # hdr = widgets.Button(\n    #     description=\"GeoDN Modeling workflow catalogue\",\n    #     disabled=True,\n    #     button_style=\"info\",  # 'success', 'info', 'warning', 'danger' or ''\n    #     layout=widgets.Layout(height=\"auto\", width=\"800px\"),\n    # )\n    hdr = widgets.HTML(value=\"&lt;h1&gt;Inference model selector&lt;/h1&gt; &lt;/p&gt;Explore which models are deployed for inference.\")\n\n    models_filter = widgets.interactive(\n        view,\n        name=keyText,\n        # tags=tagsSelect,\n        active=activeCheck,\n        layout=widgets.Layout(height=\"auto\", width=\"800px\"),\n    )\n\n    # hdr = widgets.Button(\n    #     description=\"Inference model selector\",\n    #     disabled=True,\n    #     button_style=\"info\",  # 'success', 'info', 'warning', 'danger' or ''\n    #     layout=widgets.Layout(height=\"auto\", width=\"800px\"),\n    # )\n\n    models_table = widgets.VBox(\n        [\n            hdr,\n            widgets.HBox([widgets.VBox([keyText, activeCheck])]),\n            models_filter.children[2],\n            wf_dd,\n        ],\n        layout=widgets.Layout(margin=\"20px 20px 20px 20px\", padding=\"5px 5px 5px 5px\"),\n    )\n\n    return models_table\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.fileDownloader","title":"fileDownloader","text":"<pre><code>fileDownloader(client, id)\n</code></pre> <p>Downloads the output files of an inference task.</p> <p>Parameters:</p> Name Type Description Default <code>client (</code> <p>py:class:<code>geostudio.backends.ginference.client.Client</code>): An object representing the client to interact with the inference service.</p> required <code>id</code> <code>str</code> <p>The unique identifier of the inference task.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def fileDownloader(client, id):\n    \"\"\"\n    Downloads the output files of an inference task.\n\n    Args:\n        client (:py:class:`geostudio.backends.ginference.client.Client`): An object representing the client to interact with the inference service.\n        id (str): The unique identifier of the inference task.\n\n    Returns:\n        None\n    \"\"\"\n\n    r = client.get_inference_task(id)\n    fl = list_output_files(r[\"output_url\"])\n\n    sm = widgets.SelectMultiple(\n        options=fl,\n        value=[],\n        rows=10,\n        description=\"Files:\",\n        disabled=False,\n        layout={\"width\": \"1000px\"},\n    )\n\n    db = widgets.Button(\n        description=\"Download\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me to download the selected\",\n        icon=\"check\",\n        layout=widgets.Layout(height=\"auto\", width=\"800px\"),\n    )\n\n    dlp = widgets.Text(value=\"./\", description=\"Dl path:\", disabled=False)\n\n    hdr = widgets.HTML(\n        value=\"&lt;h1&gt;Inference output downloader&lt;/h1&gt; &lt;/p&gt;Select the files and the download path and hit download.\"\n    )\n\n    output = widgets.Output()\n\n    display(hdr, sm, dlp, db, output)\n\n    def on_button_clicked(db):\n        \"\"\"This function is triggered when a button is clicked.\"\"\"\n        with output:\n            for X in list(sm.value):\n                print(\"Downloading...\", end=\"\\r\")\n                a = download_file(r[\"output_url\"], X)\n                print(a)\n\n    db.on_click(on_button_clicked)\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.fileDownloaderTasks","title":"fileDownloaderTasks","text":"<pre><code>fileDownloaderTasks(client, task_id)\n</code></pre> <p>Downloads the output files of an inference task.</p> <p>Parameters:</p> Name Type Description Default <code>client (</code> <p>py:class:<code>geostudio.backends.v2.ginference.client.Client</code>): An object representing the client to interact with the inference service.</p> required <code>task_id</code> <code>str</code> <p>The unique identifier of the inference task id.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def fileDownloaderTasks(client, task_id):\n    \"\"\"\n    Downloads the output files of an inference task.\n\n    Args:\n        client (:py:class:`geostudio.backends.v2.ginference.client.Client`): An object representing the client to interact with the inference service.\n        task_id (str): The unique identifier of the inference task id.\n\n    Returns:\n        None\n    \"\"\"\n\n    r = client.get_task_output_url(task_id)\n    fl = list_output_files(r[\"output_url\"])\n\n    sm = widgets.SelectMultiple(\n        options=fl,\n        value=[],\n        rows=10,\n        description=\"Files:\",\n        disabled=False,\n        layout={\"width\": \"1000px\"},\n    )\n\n    db = widgets.Button(\n        description=\"Download\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me to download the selected\",\n        icon=\"check\",\n        layout=widgets.Layout(height=\"auto\", width=\"800px\"),\n    )\n\n    dlp = widgets.Text(value=\"./\", description=\"Dl path:\", disabled=False)\n\n    hdr = widgets.HTML(\n        value=\"&lt;h1&gt;Inference Task output downloader&lt;/h1&gt; &lt;/p&gt;Select the files and the download path and hit download.\"\n    )\n\n    output = widgets.Output()\n\n    display(hdr, sm, dlp, db, output)\n\n    def on_button_clicked(db):\n        \"\"\"This function is triggered when a button is clicked.\"\"\"\n        with output:\n            for X in list(sm.value):\n                print(\"Downloading...\", end=\"\\r\")\n                a = download_file(r[\"output_url\"], X)\n                print(a)\n\n    db.on_click(on_button_clicked)\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.geotiff2img","title":"geotiff2img","text":"<pre><code>geotiff2img(filename, band=1, cmax='')\n</code></pre> <p>Converts a GeoTIFF file to a base64 encoded PNG image URL.</p> <p>Parameters:</p> Name Type Description Default <code>filename</code> <code>str</code> <p>The path to the GeoTIFF file.</p> required <code>band</code> <code>int</code> <p>The band number to use for the image. Default is 1.</p> <code>1</code> <code>cmax</code> <code>str or float</code> <p>The maximum value for color scaling. If not provided, it will be automatically calculated.</p> <code>''</code> <p>Returns:</p> Name Type Description <code>tuple</code> <p>A tuple containing the base64 encoded PNG image URL and the image bounds.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def geotiff2img(filename, band=1, cmax=\"\"):\n    \"\"\"\n    Converts a GeoTIFF file to a base64 encoded PNG image URL.\n\n    Args:\n        filename (str): The path to the GeoTIFF file.\n        band (int, optional): The band number to use for the image. Default is 1.\n        cmax (str or float, optional): The maximum value for color scaling. If not provided, it will be automatically calculated.\n\n    Returns:\n        tuple: A tuple containing the base64 encoded PNG image URL and the image bounds.\n    \"\"\"\n\n    if \"_rgb.tif\" not in filename:\n        # In the case of a non-RGB tagged image convert to an RGB png based on a color map from a single selected band\n        with rasterio.open(filename) as src:\n            dataArray = src.read(band)\n            bounds = src.bounds\n            nd = src.nodata\n\n        if cmax == \"\":\n            cmax = np.max(dataArray)\n        dataArrayMasked = np.ma.masked_where(dataArray == nd, dataArray)\n        imc = colorize(dataArrayMasked, cmax, cmin=0, cmap=\"viridis\")\n\n        img = 255 * imc\n        img = img.astype(np.uint8)\n        im = PIL.Image.fromarray(img, mode=\"RGBA\")\n\n    elif \"_rgb.tif\" in filename:\n        # In the case of an RGB tagged image convert to an RGB png\n        with rasterio.open(filename) as src:\n            rBand = src.read(1)\n            gBand = src.read(2)\n            bBand = src.read(3)\n            bounds = src.bounds\n            nd = src.nodata\n\n        opacity_layer = np.ma.masked_where(rBand == nd, 255 * np.ones(rBand.shape))\n        img = np.stack([rBand, gBand, bBand, opacity_layer], axis=-1)\n\n        img = 2 * img\n        img = img.astype(np.uint8)\n        im = PIL.Image.fromarray(img, mode=\"RGBA\")\n\n    f = BytesIO()\n    im.save(f, \"png\")\n\n    data = b64encode(f.getvalue())\n    data = data.decode(\"ascii\")\n    imgurl = \"data:image/png;base64,\" + data\n\n    return imgurl, bounds\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.inferenceViewer","title":"inferenceViewer","text":"<pre><code>inferenceViewer(client, id)\n</code></pre> <p>Creates a Jupyter widget for visualizing inference task outputs.</p> <p>Parameters:</p> Name Type Description Default <code>client (</code> <p>py:class:<code>geostudio.backends.ginference.client.Client</code>): An object representing the client for interacting with the inference service.</p> required <code>id</code> <code>str</code> <p>The unique identifier for the inference task.</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>A Jupyter widget containing a map with image overlays of the inference outputs.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def inferenceViewer(client, id):\n    \"\"\"\n    Creates a Jupyter widget for visualizing inference task outputs.\n\n    Args:\n        client (:py:class:`geostudio.backends.ginference.client.Client`): An object representing the client for interacting with the inference service.\n        id (str): The unique identifier for the inference task.\n\n    Returns:\n        object: A Jupyter widget containing a map with image overlays of the inference outputs.\n    \"\"\"\n\n    r = client.get_inference_task(id)\n    fl = list_output_files(r[\"output_url\"])\n\n    fl_options = [(X.split(\"/\")[-1].replace(r[\"event_id\"] + \"_\", \"\"), X) for X in fl]\n\n    sm = widgets.SelectMultiple(\n        options=fl_options,\n        value=[],\n        rows=10,\n        description=\"\",\n        disabled=False,\n        layout={\"width\": \"800px\"},\n    )\n\n    db = widgets.Button(\n        description=\"Update layers\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me to update the layers on the map\",\n        icon=\"check\",\n        layout=widgets.Layout(height=\"auto\", width=\"100px\"),\n    )\n\n    output = widgets.Output()\n\n    left = widgets.VBox([sm, db, output])\n\n    header = widgets.HTML(value=\"&lt;h1&gt;Inference output viewer&lt;/h1&gt;\")\n    footer = widgets.HTML(value=\"Thanks for using the viewer, any questions please ask....\")\n\n    map = Map(center=(52.0, 0.0), zoom=8, scroll_wheel_zoom=True, world_copy_jump=False)\n    map.add(FullScreenControl())\n    control = LayersControl(position=\"topright\")\n    map.add(control)\n\n    def on_button_clicked(db):\n        \"\"\"\n        Adds image overlays to a map based on a list of URLs.\n\n        Args:\n            db (object): The database object containing necessary information for the operation.\n\n        Returns:\n            None\n        \"\"\"\n        layer_files = []\n\n        # map.clear_layers()\n\n        with output:\n            output.clear_output()\n            for X in list(sm.value):\n                print(\"Downloading...\", end=\"\\r\")\n                a = download_file(r[\"output_url\"], X)\n                print(a)\n                layer_files = layer_files + [a]\n                imgurl, bounds = geotiff2img(X)\n                imgBounds = ((bounds.bottom, bounds.left), (bounds.top, bounds.right))\n\n                map.add(\n                    ImageOverlay(\n                        name=a.split(\"/\")[-1].replace(r[\"event_id\"] + \"_\", \"\"),\n                        url=imgurl,\n                        bounds=imgBounds,\n                        opacity=0.9,\n                    )\n                )\n                # map.add(io)\n                # map.fit_bounds([[bounds.bottom, bounds.left],[bounds.top, bounds.right]])\n                map.center = (bounds.bottom, bounds.left)\n                print(\"&gt;&gt;&gt; added to map\")\n\n    db.on_click(on_button_clicked)\n\n    return widgets.VBox(\n        [\n            header,\n            # widgets.HBox([widgets.VBox([sm, db]), output]),\n            sm,\n            db,\n            map,\n            output\n            # footer\n        ]\n    )\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.inferenceTaskViewer","title":"inferenceTaskViewer","text":"<pre><code>inferenceTaskViewer(client, task_id)\n</code></pre> <p>Creates a Jupyter widget for visualizing inference task outputs.</p> <p>Parameters:</p> Name Type Description Default <code>client (</code> <p>py:class:<code>geostudio.backends.v2.ginference.client.Client</code>): An object representing the client for interacting with the inference service.</p> required <code>task_id</code> <code>str</code> <p>The unique identifier for the inference task.</p> required <p>Returns:</p> Name Type Description <code>object</code> <p>A Jupyter widget containing a map with image overlays of the inference outputs.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def inferenceTaskViewer(client, task_id):\n    \"\"\"\n    Creates a Jupyter widget for visualizing inference task outputs.\n\n    Args:\n        client (:py:class:`geostudio.backends.v2.ginference.client.Client`): An object representing the client for interacting with the inference service.\n        task_id (str): The unique identifier for the inference task.\n\n    Returns:\n        object: A Jupyter widget containing a map with image overlays of the inference outputs.\n    \"\"\"\n\n    r = client.get_task_output_url(task_id)\n    fl = list_output_files(r[\"output_url\"])\n\n    fl_options = [(X.split(\"/\")[-1].replace(r[\"task_id\"] + \"_\", \"\"), X) for X in fl]\n\n    sm = widgets.SelectMultiple(\n        options=fl_options,\n        value=[],\n        rows=10,\n        description=\"\",\n        disabled=False,\n        layout={\"width\": \"800px\"},\n    )\n\n    db = widgets.Button(\n        description=\"Update layers\",\n        disabled=False,\n        button_style=\"\",  # 'success', 'info', 'warning', 'danger' or ''\n        tooltip=\"Click me to update the layers on the map\",\n        icon=\"check\",\n        layout=widgets.Layout(height=\"auto\", width=\"100px\"),\n    )\n\n    output = widgets.Output()\n\n    left = widgets.VBox([sm, db, output])\n\n    header = widgets.HTML(value=\"&lt;h1&gt;Inference output viewer&lt;/h1&gt;\")\n    footer = widgets.HTML(value=\"Thanks for using the viewer, any questions please ask....\")\n\n    map = Map(center=(52.0, 0.0), zoom=8, scroll_wheel_zoom=True, world_copy_jump=False)\n    map.add(FullScreenControl())\n    control = LayersControl(position=\"topright\")\n    map.add(control)\n\n    def on_button_clicked(db):\n        \"\"\"\n        Adds image overlays to a map based on a list of URLs.\n\n        Args:\n            db (object): The database object containing necessary information for the operation.\n\n        Returns:\n            None\n        \"\"\"\n        layer_files = []\n\n        # map.clear_layers()\n\n        with output:\n            output.clear_output()\n            for X in list(sm.value):\n                print(\"Downloading...\", end=\"\\r\")\n                a = download_file(r[\"output_url\"], X)\n                print(a)\n                layer_files = layer_files + [a]\n                imgurl, bounds = geotiff2img(X)\n                imgBounds = ((bounds.bottom, bounds.left), (bounds.top, bounds.right))\n\n                map.add(\n                    ImageOverlay(\n                        name=a.split(\"/\")[-1].replace(r[\"task_id\"] + \"_\", \"\"),\n                        url=imgurl,\n                        bounds=imgBounds,\n                        opacity=0.9,\n                    )\n                )\n                # map.add(io)\n                # map.fit_bounds([[bounds.bottom, bounds.left],[bounds.top, bounds.right]])\n                map.center = (bounds.bottom, bounds.left)\n                print(\"&gt;&gt;&gt; added to map\")\n\n    db.on_click(on_button_clicked)\n\n    return widgets.VBox(\n        [\n            header,\n            # widgets.HBox([widgets.VBox([sm, db]), output]),\n            sm,\n            db,\n            map,\n            output\n            # footer\n        ]\n    )\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.color_inference_tasks_by_status","title":"color_inference_tasks_by_status","text":"<pre><code>color_inference_tasks_by_status(val)\n</code></pre> <p>Takes a scalar and returns a string with the css property <code>'color: red'</code> for negative strings, black otherwise.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def color_inference_tasks_by_status(val):\n    \"\"\"\n    Takes a scalar and returns a string with\n    the css property `'color: red'` for negative\n    strings, black otherwise.\n    \"\"\"\n\n    if val == \"READY\":\n        color = \"#ffd966\"\n    elif val == \"WAITING\":\n        color = \"#f6b26b\"\n    elif val == \"RUNNING\":\n        color = \"#d9ead3\"\n    elif val == \"FINISHED\":\n        color = \"#8fce00\"\n    elif val == \"FAILED\":\n        color = \"#ff0000\"\n    elif val == \"STOP\":\n        color = \"#b00020\"\n    else:\n        color = \"black\"\n\n    return \"color: %s\" % color\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.plot_tune_metrics","title":"plot_tune_metrics","text":"<pre><code>plot_tune_metrics(client, tune_id: str, run_name: str = 'Train')\n</code></pre> <p>Plots training and validation metrics for a given tuning experiment in a 2x2 subplot grid.</p> <p>Parameters:</p> Name Type Description Default <code>tune_id</code> <code>str</code> <p>The unique identifier of the tuning experiment.</p> required <p>Returns:</p> Type Description <p>None</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def plot_tune_metrics(client, tune_id: str, run_name: str = \"Train\"):\n    \"\"\"\n    Plots training and validation metrics for a given tuning experiment in a 2x2 subplot grid.\n\n    Parameters:\n        tune_id (str): The unique identifier of the tuning experiment.\n\n    Returns:\n        None\n    \"\"\"\n    mlflow_urls = client.get_mlflow_metrics(tune_id)\n    if mlflow_urls:\n        print(mlflow_urls)\n    else:\n        return f\"Tune {tune_id}, has not started to generate metrics. Try to rerun this cell after a few moments!\"\n\n    mdf = client.get_tune_metrics_df(tune_id, run_name)\n    r = client.get_tune(tune_id)\n    status = r[\"status\"]\n\n    mdf_columns = mdf.columns.tolist()\n    if not mdf_columns:\n        return f\"Tune {tune_id}, has not started to generate metrics. Try to rerun this cell after a few moments!\"\n    mdf_columns.remove(\"epoch\")\n    mdf_columns_len = len(mdf_columns)\n\n    nrows = math.ceil(mdf_columns_len / 2)\n    ncols = 2\n    fig, axes = plt.subplots(nrows=nrows, ncols=ncols, sharex=True, sharey=False, figsize=(10, mdf_columns_len))\n    fig.tight_layout()\n    step_num = max(mdf.epoch)\n    fig.suptitle(f\"{tune_id} - {status} - Step number: {step_num}\")\n    fig.subplots_adjust(top=0.88)\n\n    axes = axes.flatten()\n\n    for i, column in enumerate(mdf_columns):\n        axes[i].plot(mdf[\"epoch\"], mdf[column], \"b.-\")\n        axes[i].set_title(column)\n        axes[i].grid(True)\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.crop_image_bytes","title":"crop_image_bytes","text":"<pre><code>crop_image_bytes(img_bytes)\n</code></pre> <p>Crops the white space from the training image provided as raw bytes and return PNG bytes.</p>"},{"location":"widgets/#geostudio.gswidgets.crop_image_bytes--parameters","title":"Parameters","text":"<p>img_bytes : bytes     Raw image bytes (any format supported by PIL.Image.open).</p>"},{"location":"widgets/#geostudio.gswidgets.crop_image_bytes--returns","title":"Returns","text":"<p>bytes     PNG-encoded bytes of the cropped image. The function uses a fixed crop box     (left=0, upper=350, right=image_width, lower=650) so the returned image contains     the horizontal strip between y=350 and y=650 from the original image.</p>"},{"location":"widgets/#geostudio.gswidgets.crop_image_bytes--notes","title":"Notes","text":"<ul> <li>The result is always encoded as PNG.</li> <li>If the crop box extends beyond the source image bounds, PIL.Image.crop behavior applies.</li> </ul> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def crop_image_bytes(img_bytes):\n    \"\"\"\n    Crops the white space from the training image provided as raw bytes and return PNG bytes.\n\n    Parameters\n    ----------\n    img_bytes : bytes\n        Raw image bytes (any format supported by PIL.Image.open).\n\n    Returns\n    -------\n    bytes\n        PNG-encoded bytes of the cropped image. The function uses a fixed crop box\n        (left=0, upper=350, right=image_width, lower=650) so the returned image contains\n        the horizontal strip between y=350 and y=650 from the original image.\n\n    Notes\n    -----\n    - The result is always encoded as PNG.\n    - If the crop box extends beyond the source image bounds, PIL.Image.crop behavior applies.\n    \"\"\"\n\n    imageFile = Image.open(io.BytesIO(img_bytes))\n    w, h = imageFile.size\n    croppedImageFile = imageFile.crop((0, 350, w, 650))\n    imgBytes = io.BytesIO()\n    croppedImageFile.save(imgBytes, format=\"PNG\")\n    return imgBytes.getvalue()\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.save_training_image","title":"save_training_image","text":"<pre><code>save_training_image(image_number, epoch, img_dict, cropped=True)\n</code></pre> <p>Save a training sample image from img_dict to a PNG file.</p>"},{"location":"widgets/#geostudio.gswidgets.save_training_image--parameters","title":"Parameters","text":"<p>image_number : int     The sample index/number to save (matches the 'image_number' key in img_dict). epoch : int     The epoch number to save (matches the 'epoch' key in img_dict). img_dict : list[dict]     List of artefact records as returned by get_tuning_artefacts. Each item must contain:       - 'filename' : str       - 'image' : bytes       - 'epoch' : int       - 'image_number' : int cropped : bool, optional     If True (default) crop the image bytes using crop_image_bytes before saving.</p>"},{"location":"widgets/#geostudio.gswidgets.save_training_image--raises","title":"Raises","text":"<p>ValueError     If no matching image is found in img_dict.</p> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def save_training_image(image_number, epoch, img_dict, cropped=True):\n    \"\"\"\n    Save a training sample image from img_dict to a PNG file.\n\n    Parameters\n    ----------\n    image_number : int\n        The sample index/number to save (matches the 'image_number' key in img_dict).\n    epoch : int\n        The epoch number to save (matches the 'epoch' key in img_dict).\n    img_dict : list[dict]\n        List of artefact records as returned by get_tuning_artefacts. Each item must contain:\n          - 'filename' : str\n          - 'image' : bytes\n          - 'epoch' : int\n          - 'image_number' : int\n    cropped : bool, optional\n        If True (default) crop the image bytes using crop_image_bytes before saving.\n\n    Raises\n    ------\n    ValueError\n        If no matching image is found in img_dict.\n    \"\"\"\n    img_bytes = [X for X in img_dict if (X[\"epoch\"] == epoch) &amp; (X[\"image_number\"] == image_number)][0][\"image\"]\n    with open(f\"training_image_epoch_{epoch}_number_{image_number}.png\", \"wb\") as f:\n        if cropped:\n            f.write(crop_image_bytes(img_bytes))\n        else:\n            f.write(img_bytes)\n</code></pre>"},{"location":"widgets/#geostudio.gswidgets.browse_training_images","title":"browse_training_images","text":"<pre><code>browse_training_images(img_dict: object, tune_id: str)\n</code></pre> <p>Create an interactive Jupyter widget viewer to browse fine-tuning sample images.</p>"},{"location":"widgets/#geostudio.gswidgets.browse_training_images--parameters","title":"Parameters","text":"<p>img_dict : list[dict]     List of artefact records. Each item must be a dict with at least the keys:       - 'filename' : str       - 'image' : bytes  (raw image bytes as returned by get_tuning_artefacts)       - 'epoch' : int       - 'image_number' : int tune_id : str     Identifier shown in the viewer header.</p>"},{"location":"widgets/#geostudio.gswidgets.browse_training_images--notes","title":"Notes","text":"<ul> <li>Depends on crop_image_bytes(img_bytes) to produce the PNG bytes shown in the widget.</li> <li>Expects img_dict to contain at least one image; raises ValueError otherwise.</li> <li>Uses ipywidgets and functools to wire button callbacks.</li> <li>To use: viewer = browse_training_images(img_dict, tune_id); display(viewer)</li> </ul> Source code in <code>geostudio/gswidgets.py</code> <pre><code>def browse_training_images(img_dict: object, tune_id: str):\n    \"\"\"\n    Create an interactive Jupyter widget viewer to browse fine-tuning sample images.\n\n    Parameters\n    ----------\n    img_dict : list[dict]\n        List of artefact records. Each item must be a dict with at least the keys:\n          - 'filename' : str\n          - 'image' : bytes  (raw image bytes as returned by get_tuning_artefacts)\n          - 'epoch' : int\n          - 'image_number' : int\n    tune_id : str\n        Identifier shown in the viewer header.\n\n    Notes\n    -----\n    - Depends on crop_image_bytes(img_bytes) to produce the PNG bytes shown in the widget.\n    - Expects img_dict to contain at least one image; raises ValueError otherwise.\n    - Uses ipywidgets and functools to wire button callbacks.\n    - To use: viewer = browse_training_images(img_dict, tune_id); display(viewer)\n    \"\"\"\n\n    if not img_dict:\n        raise ValueError(\"img_dict is empty - must contain at least one image record\")\n\n    epochs = sorted(list(set([X[\"epoch\"] for X in img_dict])))\n    image_numbers = sorted(list(set([X[\"image_number\"] for X in img_dict])))\n\n    header = widgets.HTML(value=f\"&lt;h2&gt;Fine-tuning samples - {tune_id}&lt;/h2&gt;\")\n\n    image_widget = widgets.Image(\n        value=crop_image_bytes(\n            [X for X in img_dict if (X[\"epoch\"] == epochs[0]) &amp; (X[\"image_number\"] == image_numbers[0])][0][\"image\"]\n        ),\n        format=\"png\",\n        width=800,\n        height=400,\n    )\n\n    # Create buttons for navigation\n    back_epoch_button = widgets.Button(description=\"&lt; Back\")\n    forward_epoch_button = widgets.Button(description=\"Next &gt;\")\n    back_image_button = widgets.Button(description=\"&lt; Back\")\n    forward_image_button = widgets.Button(description=\"Next &gt;\")\n\n    # Use a widget to hold the current image index\n    epoch_index_w = widgets.IntText(value=0, visible=False)\n    image_number_index_w = widgets.IntText(value=0, visible=False)\n\n    epoch_text = widgets.Text(value=str(epochs[epoch_index_w.value]), description=\"Epoch:\", disabled=True)\n    image_text = widgets.Text(\n        value=str(image_numbers[image_number_index_w.value]), description=\"Sample:\", disabled=True\n    )\n\n    # Arrange the widgets in a horizontal box\n    viewer_container = widgets.VBox(\n        [\n            header,\n            widgets.HBox([epoch_text, back_epoch_button, forward_epoch_button]),\n            widgets.HBox([image_text, back_image_button, forward_image_button]),\n            image_widget,\n        ]\n    )\n\n    # Create a function to handle button clicks\n    def on_epoch_button_click(b, epochs=[], image_numbers=[]):\n        current_index = epoch_index_w.value\n        max_index = len(epochs) - 1\n\n        if b.description == \"Next &gt;\" and current_index &lt; max_index:\n            epoch_index_w.value += 1\n        elif b.description == \"&lt; Back\" and current_index &gt; 0:\n            epoch_index_w.value -= 1\n\n        epoch_text.value = str(epochs[epoch_index_w.value])\n\n        # Update the displayed image\n        image_widget.value = crop_image_bytes(\n            [\n                X\n                for X in img_dict\n                if (X[\"epoch\"] == epochs[epoch_index_w.value])\n                &amp; (X[\"image_number\"] == image_numbers[image_number_index_w.value])\n            ][0][\"image\"]\n        )\n\n    # Attach the click event to the buttons\n    back_epoch_button.on_click(functools.partial(on_epoch_button_click, epochs=epochs, image_numbers=image_numbers))\n    forward_epoch_button.on_click(functools.partial(on_epoch_button_click, epochs=epochs, image_numbers=image_numbers))\n\n    def on_image_button_click(b, epochs=[], image_numbers=[]):\n        current_index = image_number_index_w.value\n        max_index = len(image_numbers) - 1\n\n        if b.description == \"Next &gt;\" and current_index &lt; max_index:\n            image_number_index_w.value += 1\n        elif b.description == \"&lt; Back\" and current_index &gt; 0:\n            image_number_index_w.value -= 1\n\n        image_text.value = str(image_numbers[image_number_index_w.value])\n\n        # Update the displayed image\n        image_widget.value = crop_image_bytes(\n            [\n                X\n                for X in img_dict\n                if (X[\"epoch\"] == epochs[epoch_index_w.value])\n                &amp; (X[\"image_number\"] == image_numbers[image_number_index_w.value])\n            ][0][\"image\"]\n        )\n\n    # Attach the click event to the buttons\n    back_image_button.on_click(functools.partial(on_image_button_click, epochs=epochs, image_numbers=image_numbers))\n    forward_image_button.on_click(functools.partial(on_image_button_click, epochs=epochs, image_numbers=image_numbers))\n\n    # Display the interactive viewer\n    return viewer_container\n</code></pre>"}]}